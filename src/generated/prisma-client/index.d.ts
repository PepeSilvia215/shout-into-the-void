// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  echo: (where?: EchoWhereInput) => Promise<boolean>;
  nVoid: (where?: NVoidWhereInput) => Promise<boolean>;
  reply: (where?: ReplyWhereInput) => Promise<boolean>;
  shout: (where?: ShoutWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  echo: (where: EchoWhereUniqueInput) => EchoNullablePromise;
  echoes: (args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Echo>;
  echoesConnection: (args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EchoConnectionPromise;
  nVoid: (where: NVoidWhereUniqueInput) => NVoidNullablePromise;
  nVoids: (args?: {
    where?: NVoidWhereInput;
    orderBy?: NVoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NVoid>;
  nVoidsConnection: (args?: {
    where?: NVoidWhereInput;
    orderBy?: NVoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NVoidConnectionPromise;
  reply: (where: ReplyWhereUniqueInput) => ReplyNullablePromise;
  replies: (args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Reply>;
  repliesConnection: (args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReplyConnectionPromise;
  shout: (where: ShoutWhereUniqueInput) => ShoutNullablePromise;
  shouts: (args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Shout>;
  shoutsConnection: (args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShoutConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createEcho: (data: EchoCreateInput) => EchoPromise;
  updateEcho: (args: {
    data: EchoUpdateInput;
    where: EchoWhereUniqueInput;
  }) => EchoPromise;
  upsertEcho: (args: {
    where: EchoWhereUniqueInput;
    create: EchoCreateInput;
    update: EchoUpdateInput;
  }) => EchoPromise;
  deleteEcho: (where: EchoWhereUniqueInput) => EchoPromise;
  deleteManyEchoes: (where?: EchoWhereInput) => BatchPayloadPromise;
  createNVoid: (data: NVoidCreateInput) => NVoidPromise;
  updateNVoid: (args: {
    data: NVoidUpdateInput;
    where: NVoidWhereUniqueInput;
  }) => NVoidPromise;
  updateManyNVoids: (args: {
    data: NVoidUpdateManyMutationInput;
    where?: NVoidWhereInput;
  }) => BatchPayloadPromise;
  upsertNVoid: (args: {
    where: NVoidWhereUniqueInput;
    create: NVoidCreateInput;
    update: NVoidUpdateInput;
  }) => NVoidPromise;
  deleteNVoid: (where: NVoidWhereUniqueInput) => NVoidPromise;
  deleteManyNVoids: (where?: NVoidWhereInput) => BatchPayloadPromise;
  createReply: (data: ReplyCreateInput) => ReplyPromise;
  updateReply: (args: {
    data: ReplyUpdateInput;
    where: ReplyWhereUniqueInput;
  }) => ReplyPromise;
  updateManyReplies: (args: {
    data: ReplyUpdateManyMutationInput;
    where?: ReplyWhereInput;
  }) => BatchPayloadPromise;
  upsertReply: (args: {
    where: ReplyWhereUniqueInput;
    create: ReplyCreateInput;
    update: ReplyUpdateInput;
  }) => ReplyPromise;
  deleteReply: (where: ReplyWhereUniqueInput) => ReplyPromise;
  deleteManyReplies: (where?: ReplyWhereInput) => BatchPayloadPromise;
  createShout: (data: ShoutCreateInput) => ShoutPromise;
  updateShout: (args: {
    data: ShoutUpdateInput;
    where: ShoutWhereUniqueInput;
  }) => ShoutPromise;
  updateManyShouts: (args: {
    data: ShoutUpdateManyMutationInput;
    where?: ShoutWhereInput;
  }) => BatchPayloadPromise;
  upsertShout: (args: {
    where: ShoutWhereUniqueInput;
    create: ShoutCreateInput;
    update: ShoutUpdateInput;
  }) => ShoutPromise;
  deleteShout: (where: ShoutWhereUniqueInput) => ShoutPromise;
  deleteManyShouts: (where?: ShoutWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  echo: (
    where?: EchoSubscriptionWhereInput
  ) => EchoSubscriptionPayloadSubscription;
  nVoid: (
    where?: NVoidSubscriptionWhereInput
  ) => NVoidSubscriptionPayloadSubscription;
  reply: (
    where?: ReplySubscriptionWhereInput
  ) => ReplySubscriptionPayloadSubscription;
  shout: (
    where?: ShoutSubscriptionWhereInput
  ) => ShoutSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ShoutOrderByInput =
  | "voteCount_ASC"
  | "voteCount_DESC"
  | "shoutId_ASC"
  | "shoutId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "content_ASC"
  | "content_DESC";

export type EchoOrderByInput =
  | "echoId_ASC"
  | "echoId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type NVoidOrderByInput =
  | "nvoidId_ASC"
  | "nvoidId_DESC"
  | "geohash_ASC"
  | "geohash_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ReplyOrderByInput =
  | "voteCount_ASC"
  | "voteCount_DESC"
  | "replyId_ASC"
  | "replyId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "content_ASC"
  | "content_DESC";

export type UserOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "currentLocationGeohash_ASC"
  | "currentLocationGeohash_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type EchoWhereUniqueInput = AtLeastOne<{
  echoId: Maybe<ID_Input>;
}>;

export interface ShoutWhereInput {
  voteCount?: Maybe<Int>;
  voteCount_not?: Maybe<Int>;
  voteCount_in?: Maybe<Int[] | Int>;
  voteCount_not_in?: Maybe<Int[] | Int>;
  voteCount_lt?: Maybe<Int>;
  voteCount_lte?: Maybe<Int>;
  voteCount_gt?: Maybe<Int>;
  voteCount_gte?: Maybe<Int>;
  shoutId?: Maybe<ID_Input>;
  shoutId_not?: Maybe<ID_Input>;
  shoutId_in?: Maybe<ID_Input[] | ID_Input>;
  shoutId_not_in?: Maybe<ID_Input[] | ID_Input>;
  shoutId_lt?: Maybe<ID_Input>;
  shoutId_lte?: Maybe<ID_Input>;
  shoutId_gt?: Maybe<ID_Input>;
  shoutId_gte?: Maybe<ID_Input>;
  shoutId_contains?: Maybe<ID_Input>;
  shoutId_not_contains?: Maybe<ID_Input>;
  shoutId_starts_with?: Maybe<ID_Input>;
  shoutId_not_starts_with?: Maybe<ID_Input>;
  shoutId_ends_with?: Maybe<ID_Input>;
  shoutId_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  postedBy?: Maybe<UserWhereInput>;
  echos_every?: Maybe<EchoWhereInput>;
  echos_some?: Maybe<EchoWhereInput>;
  echos_none?: Maybe<EchoWhereInput>;
  nvoid?: Maybe<NVoidWhereInput>;
  replies_every?: Maybe<ReplyWhereInput>;
  replies_some?: Maybe<ReplyWhereInput>;
  replies_none?: Maybe<ReplyWhereInput>;
  AND?: Maybe<ShoutWhereInput[] | ShoutWhereInput>;
  OR?: Maybe<ShoutWhereInput[] | ShoutWhereInput>;
  NOT?: Maybe<ShoutWhereInput[] | ShoutWhereInput>;
}

export interface UserWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  userId?: Maybe<ID_Input>;
  userId_not?: Maybe<ID_Input>;
  userId_in?: Maybe<ID_Input[] | ID_Input>;
  userId_not_in?: Maybe<ID_Input[] | ID_Input>;
  userId_lt?: Maybe<ID_Input>;
  userId_lte?: Maybe<ID_Input>;
  userId_gt?: Maybe<ID_Input>;
  userId_gte?: Maybe<ID_Input>;
  userId_contains?: Maybe<ID_Input>;
  userId_not_contains?: Maybe<ID_Input>;
  userId_starts_with?: Maybe<ID_Input>;
  userId_not_starts_with?: Maybe<ID_Input>;
  userId_ends_with?: Maybe<ID_Input>;
  userId_not_ends_with?: Maybe<ID_Input>;
  createdShouts_every?: Maybe<ShoutWhereInput>;
  createdShouts_some?: Maybe<ShoutWhereInput>;
  createdShouts_none?: Maybe<ShoutWhereInput>;
  savedShouts_every?: Maybe<ShoutWhereInput>;
  savedShouts_some?: Maybe<ShoutWhereInput>;
  savedShouts_none?: Maybe<ShoutWhereInput>;
  echoedShouts_every?: Maybe<EchoWhereInput>;
  echoedShouts_some?: Maybe<EchoWhereInput>;
  echoedShouts_none?: Maybe<EchoWhereInput>;
  echoes_every?: Maybe<EchoWhereInput>;
  echoes_some?: Maybe<EchoWhereInput>;
  echoes_none?: Maybe<EchoWhereInput>;
  savedVoids_every?: Maybe<NVoidWhereInput>;
  savedVoids_some?: Maybe<NVoidWhereInput>;
  savedVoids_none?: Maybe<NVoidWhereInput>;
  currentLocationGeohash?: Maybe<String>;
  currentLocationGeohash_not?: Maybe<String>;
  currentLocationGeohash_in?: Maybe<String[] | String>;
  currentLocationGeohash_not_in?: Maybe<String[] | String>;
  currentLocationGeohash_lt?: Maybe<String>;
  currentLocationGeohash_lte?: Maybe<String>;
  currentLocationGeohash_gt?: Maybe<String>;
  currentLocationGeohash_gte?: Maybe<String>;
  currentLocationGeohash_contains?: Maybe<String>;
  currentLocationGeohash_not_contains?: Maybe<String>;
  currentLocationGeohash_starts_with?: Maybe<String>;
  currentLocationGeohash_not_starts_with?: Maybe<String>;
  currentLocationGeohash_ends_with?: Maybe<String>;
  currentLocationGeohash_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  replies_every?: Maybe<ReplyWhereInput>;
  replies_some?: Maybe<ReplyWhereInput>;
  replies_none?: Maybe<ReplyWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface EchoWhereInput {
  echoId?: Maybe<ID_Input>;
  echoId_not?: Maybe<ID_Input>;
  echoId_in?: Maybe<ID_Input[] | ID_Input>;
  echoId_not_in?: Maybe<ID_Input[] | ID_Input>;
  echoId_lt?: Maybe<ID_Input>;
  echoId_lte?: Maybe<ID_Input>;
  echoId_gt?: Maybe<ID_Input>;
  echoId_gte?: Maybe<ID_Input>;
  echoId_contains?: Maybe<ID_Input>;
  echoId_not_contains?: Maybe<ID_Input>;
  echoId_starts_with?: Maybe<ID_Input>;
  echoId_not_starts_with?: Maybe<ID_Input>;
  echoId_ends_with?: Maybe<ID_Input>;
  echoId_not_ends_with?: Maybe<ID_Input>;
  nvoid?: Maybe<NVoidWhereInput>;
  originalShout?: Maybe<ShoutWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserWhereInput>;
  echoedBy?: Maybe<UserWhereInput>;
  AND?: Maybe<EchoWhereInput[] | EchoWhereInput>;
  OR?: Maybe<EchoWhereInput[] | EchoWhereInput>;
  NOT?: Maybe<EchoWhereInput[] | EchoWhereInput>;
}

export interface NVoidWhereInput {
  nvoidId?: Maybe<ID_Input>;
  nvoidId_not?: Maybe<ID_Input>;
  nvoidId_in?: Maybe<ID_Input[] | ID_Input>;
  nvoidId_not_in?: Maybe<ID_Input[] | ID_Input>;
  nvoidId_lt?: Maybe<ID_Input>;
  nvoidId_lte?: Maybe<ID_Input>;
  nvoidId_gt?: Maybe<ID_Input>;
  nvoidId_gte?: Maybe<ID_Input>;
  nvoidId_contains?: Maybe<ID_Input>;
  nvoidId_not_contains?: Maybe<ID_Input>;
  nvoidId_starts_with?: Maybe<ID_Input>;
  nvoidId_not_starts_with?: Maybe<ID_Input>;
  nvoidId_ends_with?: Maybe<ID_Input>;
  nvoidId_not_ends_with?: Maybe<ID_Input>;
  geohash?: Maybe<String>;
  geohash_not?: Maybe<String>;
  geohash_in?: Maybe<String[] | String>;
  geohash_not_in?: Maybe<String[] | String>;
  geohash_lt?: Maybe<String>;
  geohash_lte?: Maybe<String>;
  geohash_gt?: Maybe<String>;
  geohash_gte?: Maybe<String>;
  geohash_contains?: Maybe<String>;
  geohash_not_contains?: Maybe<String>;
  geohash_starts_with?: Maybe<String>;
  geohash_not_starts_with?: Maybe<String>;
  geohash_ends_with?: Maybe<String>;
  geohash_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  shouts_every?: Maybe<ShoutWhereInput>;
  shouts_some?: Maybe<ShoutWhereInput>;
  shouts_none?: Maybe<ShoutWhereInput>;
  echos_every?: Maybe<EchoWhereInput>;
  echos_some?: Maybe<EchoWhereInput>;
  echos_none?: Maybe<EchoWhereInput>;
  AND?: Maybe<NVoidWhereInput[] | NVoidWhereInput>;
  OR?: Maybe<NVoidWhereInput[] | NVoidWhereInput>;
  NOT?: Maybe<NVoidWhereInput[] | NVoidWhereInput>;
}

export interface ReplyWhereInput {
  originalShout?: Maybe<ShoutWhereInput>;
  voteCount?: Maybe<Int>;
  voteCount_not?: Maybe<Int>;
  voteCount_in?: Maybe<Int[] | Int>;
  voteCount_not_in?: Maybe<Int[] | Int>;
  voteCount_lt?: Maybe<Int>;
  voteCount_lte?: Maybe<Int>;
  voteCount_gt?: Maybe<Int>;
  voteCount_gte?: Maybe<Int>;
  replyId?: Maybe<ID_Input>;
  replyId_not?: Maybe<ID_Input>;
  replyId_in?: Maybe<ID_Input[] | ID_Input>;
  replyId_not_in?: Maybe<ID_Input[] | ID_Input>;
  replyId_lt?: Maybe<ID_Input>;
  replyId_lte?: Maybe<ID_Input>;
  replyId_gt?: Maybe<ID_Input>;
  replyId_gte?: Maybe<ID_Input>;
  replyId_contains?: Maybe<ID_Input>;
  replyId_not_contains?: Maybe<ID_Input>;
  replyId_starts_with?: Maybe<ID_Input>;
  replyId_not_starts_with?: Maybe<ID_Input>;
  replyId_ends_with?: Maybe<ID_Input>;
  replyId_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  postedBy?: Maybe<UserWhereInput>;
  AND?: Maybe<ReplyWhereInput[] | ReplyWhereInput>;
  OR?: Maybe<ReplyWhereInput[] | ReplyWhereInput>;
  NOT?: Maybe<ReplyWhereInput[] | ReplyWhereInput>;
}

export type NVoidWhereUniqueInput = AtLeastOne<{
  nvoidId: Maybe<ID_Input>;
}>;

export type ReplyWhereUniqueInput = AtLeastOne<{
  replyId: Maybe<ID_Input>;
}>;

export type ShoutWhereUniqueInput = AtLeastOne<{
  shoutId: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  userId: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface EchoCreateInput {
  echoId?: Maybe<ID_Input>;
  nvoid: NVoidCreateOneWithoutEchosInput;
  originalShout: ShoutCreateOneWithoutEchosInput;
  createdBy: UserCreateOneWithoutEchoesInput;
  echoedBy: UserCreateOneWithoutEchoedShoutsInput;
}

export interface NVoidCreateOneWithoutEchosInput {
  create?: Maybe<NVoidCreateWithoutEchosInput>;
  connect?: Maybe<NVoidWhereUniqueInput>;
}

export interface NVoidCreateWithoutEchosInput {
  nvoidId?: Maybe<ID_Input>;
  geohash: String;
  shouts?: Maybe<ShoutCreateManyWithoutNvoidInput>;
}

export interface ShoutCreateManyWithoutNvoidInput {
  create?: Maybe<ShoutCreateWithoutNvoidInput[] | ShoutCreateWithoutNvoidInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
}

export interface ShoutCreateWithoutNvoidInput {
  voteCount: Int;
  shoutId?: Maybe<ID_Input>;
  content: String;
  postedBy: UserCreateOneWithoutCreatedShoutsInput;
  echos?: Maybe<EchoCreateManyWithoutOriginalShoutInput>;
  replies?: Maybe<ReplyCreateManyWithoutOriginalShoutInput>;
}

export interface UserCreateOneWithoutCreatedShoutsInput {
  create?: Maybe<UserCreateWithoutCreatedShoutsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCreatedShoutsInput {
  userId?: Maybe<ID_Input>;
  savedShouts?: Maybe<ShoutCreateManyInput>;
  echoedShouts?: Maybe<EchoCreateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoCreateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<NVoidCreateManyInput>;
  currentLocationGeohash: String;
  username: String;
  password: String;
  replies?: Maybe<ReplyCreateManyWithoutPostedByInput>;
}

export interface ShoutCreateManyInput {
  create?: Maybe<ShoutCreateInput[] | ShoutCreateInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
}

export interface ShoutCreateInput {
  voteCount: Int;
  shoutId?: Maybe<ID_Input>;
  content: String;
  postedBy: UserCreateOneWithoutCreatedShoutsInput;
  echos?: Maybe<EchoCreateManyWithoutOriginalShoutInput>;
  nvoid: NVoidCreateOneWithoutShoutsInput;
  replies?: Maybe<ReplyCreateManyWithoutOriginalShoutInput>;
}

export interface EchoCreateManyWithoutOriginalShoutInput {
  create?: Maybe<
    EchoCreateWithoutOriginalShoutInput[] | EchoCreateWithoutOriginalShoutInput
  >;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
}

export interface EchoCreateWithoutOriginalShoutInput {
  echoId?: Maybe<ID_Input>;
  nvoid: NVoidCreateOneWithoutEchosInput;
  createdBy: UserCreateOneWithoutEchoesInput;
  echoedBy: UserCreateOneWithoutEchoedShoutsInput;
}

export interface UserCreateOneWithoutEchoesInput {
  create?: Maybe<UserCreateWithoutEchoesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEchoesInput {
  userId?: Maybe<ID_Input>;
  createdShouts?: Maybe<ShoutCreateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutCreateManyInput>;
  echoedShouts?: Maybe<EchoCreateManyWithoutEchoedByInput>;
  savedVoids?: Maybe<NVoidCreateManyInput>;
  currentLocationGeohash: String;
  username: String;
  password: String;
  replies?: Maybe<ReplyCreateManyWithoutPostedByInput>;
}

export interface ShoutCreateManyWithoutPostedByInput {
  create?: Maybe<
    ShoutCreateWithoutPostedByInput[] | ShoutCreateWithoutPostedByInput
  >;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
}

export interface ShoutCreateWithoutPostedByInput {
  voteCount: Int;
  shoutId?: Maybe<ID_Input>;
  content: String;
  echos?: Maybe<EchoCreateManyWithoutOriginalShoutInput>;
  nvoid: NVoidCreateOneWithoutShoutsInput;
  replies?: Maybe<ReplyCreateManyWithoutOriginalShoutInput>;
}

export interface NVoidCreateOneWithoutShoutsInput {
  create?: Maybe<NVoidCreateWithoutShoutsInput>;
  connect?: Maybe<NVoidWhereUniqueInput>;
}

export interface NVoidCreateWithoutShoutsInput {
  nvoidId?: Maybe<ID_Input>;
  geohash: String;
  echos?: Maybe<EchoCreateManyWithoutNvoidInput>;
}

export interface EchoCreateManyWithoutNvoidInput {
  create?: Maybe<EchoCreateWithoutNvoidInput[] | EchoCreateWithoutNvoidInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
}

export interface EchoCreateWithoutNvoidInput {
  echoId?: Maybe<ID_Input>;
  originalShout: ShoutCreateOneWithoutEchosInput;
  createdBy: UserCreateOneWithoutEchoesInput;
  echoedBy: UserCreateOneWithoutEchoedShoutsInput;
}

export interface ShoutCreateOneWithoutEchosInput {
  create?: Maybe<ShoutCreateWithoutEchosInput>;
  connect?: Maybe<ShoutWhereUniqueInput>;
}

export interface ShoutCreateWithoutEchosInput {
  voteCount: Int;
  shoutId?: Maybe<ID_Input>;
  content: String;
  postedBy: UserCreateOneWithoutCreatedShoutsInput;
  nvoid: NVoidCreateOneWithoutShoutsInput;
  replies?: Maybe<ReplyCreateManyWithoutOriginalShoutInput>;
}

export interface ReplyCreateManyWithoutOriginalShoutInput {
  create?: Maybe<
    | ReplyCreateWithoutOriginalShoutInput[]
    | ReplyCreateWithoutOriginalShoutInput
  >;
  connect?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
}

export interface ReplyCreateWithoutOriginalShoutInput {
  voteCount: Int;
  replyId?: Maybe<ID_Input>;
  content: String;
  postedBy: UserCreateOneWithoutRepliesInput;
}

export interface UserCreateOneWithoutRepliesInput {
  create?: Maybe<UserCreateWithoutRepliesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutRepliesInput {
  userId?: Maybe<ID_Input>;
  createdShouts?: Maybe<ShoutCreateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutCreateManyInput>;
  echoedShouts?: Maybe<EchoCreateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoCreateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<NVoidCreateManyInput>;
  currentLocationGeohash: String;
  username: String;
  password: String;
}

export interface EchoCreateManyWithoutEchoedByInput {
  create?: Maybe<
    EchoCreateWithoutEchoedByInput[] | EchoCreateWithoutEchoedByInput
  >;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
}

export interface EchoCreateWithoutEchoedByInput {
  echoId?: Maybe<ID_Input>;
  nvoid: NVoidCreateOneWithoutEchosInput;
  originalShout: ShoutCreateOneWithoutEchosInput;
  createdBy: UserCreateOneWithoutEchoesInput;
}

export interface EchoCreateManyWithoutCreatedByInput {
  create?: Maybe<
    EchoCreateWithoutCreatedByInput[] | EchoCreateWithoutCreatedByInput
  >;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
}

export interface EchoCreateWithoutCreatedByInput {
  echoId?: Maybe<ID_Input>;
  nvoid: NVoidCreateOneWithoutEchosInput;
  originalShout: ShoutCreateOneWithoutEchosInput;
  echoedBy: UserCreateOneWithoutEchoedShoutsInput;
}

export interface UserCreateOneWithoutEchoedShoutsInput {
  create?: Maybe<UserCreateWithoutEchoedShoutsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEchoedShoutsInput {
  userId?: Maybe<ID_Input>;
  createdShouts?: Maybe<ShoutCreateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutCreateManyInput>;
  echoes?: Maybe<EchoCreateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<NVoidCreateManyInput>;
  currentLocationGeohash: String;
  username: String;
  password: String;
  replies?: Maybe<ReplyCreateManyWithoutPostedByInput>;
}

export interface NVoidCreateManyInput {
  create?: Maybe<NVoidCreateInput[] | NVoidCreateInput>;
  connect?: Maybe<NVoidWhereUniqueInput[] | NVoidWhereUniqueInput>;
}

export interface NVoidCreateInput {
  nvoidId?: Maybe<ID_Input>;
  geohash: String;
  shouts?: Maybe<ShoutCreateManyWithoutNvoidInput>;
  echos?: Maybe<EchoCreateManyWithoutNvoidInput>;
}

export interface ReplyCreateManyWithoutPostedByInput {
  create?: Maybe<
    ReplyCreateWithoutPostedByInput[] | ReplyCreateWithoutPostedByInput
  >;
  connect?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
}

export interface ReplyCreateWithoutPostedByInput {
  originalShout: ShoutCreateOneWithoutRepliesInput;
  voteCount: Int;
  replyId?: Maybe<ID_Input>;
  content: String;
}

export interface ShoutCreateOneWithoutRepliesInput {
  create?: Maybe<ShoutCreateWithoutRepliesInput>;
  connect?: Maybe<ShoutWhereUniqueInput>;
}

export interface ShoutCreateWithoutRepliesInput {
  voteCount: Int;
  shoutId?: Maybe<ID_Input>;
  content: String;
  postedBy: UserCreateOneWithoutCreatedShoutsInput;
  echos?: Maybe<EchoCreateManyWithoutOriginalShoutInput>;
  nvoid: NVoidCreateOneWithoutShoutsInput;
}

export interface EchoUpdateInput {
  nvoid?: Maybe<NVoidUpdateOneRequiredWithoutEchosInput>;
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutEchosInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutEchoesInput>;
  echoedBy?: Maybe<UserUpdateOneRequiredWithoutEchoedShoutsInput>;
}

export interface NVoidUpdateOneRequiredWithoutEchosInput {
  create?: Maybe<NVoidCreateWithoutEchosInput>;
  update?: Maybe<NVoidUpdateWithoutEchosDataInput>;
  upsert?: Maybe<NVoidUpsertWithoutEchosInput>;
  connect?: Maybe<NVoidWhereUniqueInput>;
}

export interface NVoidUpdateWithoutEchosDataInput {
  geohash?: Maybe<String>;
  shouts?: Maybe<ShoutUpdateManyWithoutNvoidInput>;
}

export interface ShoutUpdateManyWithoutNvoidInput {
  create?: Maybe<ShoutCreateWithoutNvoidInput[] | ShoutCreateWithoutNvoidInput>;
  delete?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  set?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  disconnect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  update?: Maybe<
    | ShoutUpdateWithWhereUniqueWithoutNvoidInput[]
    | ShoutUpdateWithWhereUniqueWithoutNvoidInput
  >;
  upsert?: Maybe<
    | ShoutUpsertWithWhereUniqueWithoutNvoidInput[]
    | ShoutUpsertWithWhereUniqueWithoutNvoidInput
  >;
  deleteMany?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  updateMany?: Maybe<
    ShoutUpdateManyWithWhereNestedInput[] | ShoutUpdateManyWithWhereNestedInput
  >;
}

export interface ShoutUpdateWithWhereUniqueWithoutNvoidInput {
  where: ShoutWhereUniqueInput;
  data: ShoutUpdateWithoutNvoidDataInput;
}

export interface ShoutUpdateWithoutNvoidDataInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCreatedShoutsInput>;
  echos?: Maybe<EchoUpdateManyWithoutOriginalShoutInput>;
  replies?: Maybe<ReplyUpdateManyWithoutOriginalShoutInput>;
}

export interface UserUpdateOneRequiredWithoutCreatedShoutsInput {
  create?: Maybe<UserCreateWithoutCreatedShoutsInput>;
  update?: Maybe<UserUpdateWithoutCreatedShoutsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCreatedShoutsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCreatedShoutsDataInput {
  savedShouts?: Maybe<ShoutUpdateManyInput>;
  echoedShouts?: Maybe<EchoUpdateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoUpdateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<NVoidUpdateManyInput>;
  currentLocationGeohash?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  replies?: Maybe<ReplyUpdateManyWithoutPostedByInput>;
}

export interface ShoutUpdateManyInput {
  create?: Maybe<ShoutCreateInput[] | ShoutCreateInput>;
  update?: Maybe<
    | ShoutUpdateWithWhereUniqueNestedInput[]
    | ShoutUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ShoutUpsertWithWhereUniqueNestedInput[]
    | ShoutUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  set?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  disconnect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  deleteMany?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  updateMany?: Maybe<
    ShoutUpdateManyWithWhereNestedInput[] | ShoutUpdateManyWithWhereNestedInput
  >;
}

export interface ShoutUpdateWithWhereUniqueNestedInput {
  where: ShoutWhereUniqueInput;
  data: ShoutUpdateDataInput;
}

export interface ShoutUpdateDataInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCreatedShoutsInput>;
  echos?: Maybe<EchoUpdateManyWithoutOriginalShoutInput>;
  nvoid?: Maybe<NVoidUpdateOneRequiredWithoutShoutsInput>;
  replies?: Maybe<ReplyUpdateManyWithoutOriginalShoutInput>;
}

export interface EchoUpdateManyWithoutOriginalShoutInput {
  create?: Maybe<
    EchoCreateWithoutOriginalShoutInput[] | EchoCreateWithoutOriginalShoutInput
  >;
  delete?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  set?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  disconnect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  update?: Maybe<
    | EchoUpdateWithWhereUniqueWithoutOriginalShoutInput[]
    | EchoUpdateWithWhereUniqueWithoutOriginalShoutInput
  >;
  upsert?: Maybe<
    | EchoUpsertWithWhereUniqueWithoutOriginalShoutInput[]
    | EchoUpsertWithWhereUniqueWithoutOriginalShoutInput
  >;
  deleteMany?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface EchoUpdateWithWhereUniqueWithoutOriginalShoutInput {
  where: EchoWhereUniqueInput;
  data: EchoUpdateWithoutOriginalShoutDataInput;
}

export interface EchoUpdateWithoutOriginalShoutDataInput {
  nvoid?: Maybe<NVoidUpdateOneRequiredWithoutEchosInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutEchoesInput>;
  echoedBy?: Maybe<UserUpdateOneRequiredWithoutEchoedShoutsInput>;
}

export interface UserUpdateOneRequiredWithoutEchoesInput {
  create?: Maybe<UserCreateWithoutEchoesInput>;
  update?: Maybe<UserUpdateWithoutEchoesDataInput>;
  upsert?: Maybe<UserUpsertWithoutEchoesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEchoesDataInput {
  createdShouts?: Maybe<ShoutUpdateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutUpdateManyInput>;
  echoedShouts?: Maybe<EchoUpdateManyWithoutEchoedByInput>;
  savedVoids?: Maybe<NVoidUpdateManyInput>;
  currentLocationGeohash?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  replies?: Maybe<ReplyUpdateManyWithoutPostedByInput>;
}

export interface ShoutUpdateManyWithoutPostedByInput {
  create?: Maybe<
    ShoutCreateWithoutPostedByInput[] | ShoutCreateWithoutPostedByInput
  >;
  delete?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  set?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  disconnect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  update?: Maybe<
    | ShoutUpdateWithWhereUniqueWithoutPostedByInput[]
    | ShoutUpdateWithWhereUniqueWithoutPostedByInput
  >;
  upsert?: Maybe<
    | ShoutUpsertWithWhereUniqueWithoutPostedByInput[]
    | ShoutUpsertWithWhereUniqueWithoutPostedByInput
  >;
  deleteMany?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  updateMany?: Maybe<
    ShoutUpdateManyWithWhereNestedInput[] | ShoutUpdateManyWithWhereNestedInput
  >;
}

export interface ShoutUpdateWithWhereUniqueWithoutPostedByInput {
  where: ShoutWhereUniqueInput;
  data: ShoutUpdateWithoutPostedByDataInput;
}

export interface ShoutUpdateWithoutPostedByDataInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
  echos?: Maybe<EchoUpdateManyWithoutOriginalShoutInput>;
  nvoid?: Maybe<NVoidUpdateOneRequiredWithoutShoutsInput>;
  replies?: Maybe<ReplyUpdateManyWithoutOriginalShoutInput>;
}

export interface NVoidUpdateOneRequiredWithoutShoutsInput {
  create?: Maybe<NVoidCreateWithoutShoutsInput>;
  update?: Maybe<NVoidUpdateWithoutShoutsDataInput>;
  upsert?: Maybe<NVoidUpsertWithoutShoutsInput>;
  connect?: Maybe<NVoidWhereUniqueInput>;
}

export interface NVoidUpdateWithoutShoutsDataInput {
  geohash?: Maybe<String>;
  echos?: Maybe<EchoUpdateManyWithoutNvoidInput>;
}

export interface EchoUpdateManyWithoutNvoidInput {
  create?: Maybe<EchoCreateWithoutNvoidInput[] | EchoCreateWithoutNvoidInput>;
  delete?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  set?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  disconnect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  update?: Maybe<
    | EchoUpdateWithWhereUniqueWithoutNvoidInput[]
    | EchoUpdateWithWhereUniqueWithoutNvoidInput
  >;
  upsert?: Maybe<
    | EchoUpsertWithWhereUniqueWithoutNvoidInput[]
    | EchoUpsertWithWhereUniqueWithoutNvoidInput
  >;
  deleteMany?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface EchoUpdateWithWhereUniqueWithoutNvoidInput {
  where: EchoWhereUniqueInput;
  data: EchoUpdateWithoutNvoidDataInput;
}

export interface EchoUpdateWithoutNvoidDataInput {
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutEchosInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutEchoesInput>;
  echoedBy?: Maybe<UserUpdateOneRequiredWithoutEchoedShoutsInput>;
}

export interface ShoutUpdateOneRequiredWithoutEchosInput {
  create?: Maybe<ShoutCreateWithoutEchosInput>;
  update?: Maybe<ShoutUpdateWithoutEchosDataInput>;
  upsert?: Maybe<ShoutUpsertWithoutEchosInput>;
  connect?: Maybe<ShoutWhereUniqueInput>;
}

export interface ShoutUpdateWithoutEchosDataInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCreatedShoutsInput>;
  nvoid?: Maybe<NVoidUpdateOneRequiredWithoutShoutsInput>;
  replies?: Maybe<ReplyUpdateManyWithoutOriginalShoutInput>;
}

export interface ReplyUpdateManyWithoutOriginalShoutInput {
  create?: Maybe<
    | ReplyCreateWithoutOriginalShoutInput[]
    | ReplyCreateWithoutOriginalShoutInput
  >;
  delete?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  connect?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  set?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  disconnect?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  update?: Maybe<
    | ReplyUpdateWithWhereUniqueWithoutOriginalShoutInput[]
    | ReplyUpdateWithWhereUniqueWithoutOriginalShoutInput
  >;
  upsert?: Maybe<
    | ReplyUpsertWithWhereUniqueWithoutOriginalShoutInput[]
    | ReplyUpsertWithWhereUniqueWithoutOriginalShoutInput
  >;
  deleteMany?: Maybe<ReplyScalarWhereInput[] | ReplyScalarWhereInput>;
  updateMany?: Maybe<
    ReplyUpdateManyWithWhereNestedInput[] | ReplyUpdateManyWithWhereNestedInput
  >;
}

export interface ReplyUpdateWithWhereUniqueWithoutOriginalShoutInput {
  where: ReplyWhereUniqueInput;
  data: ReplyUpdateWithoutOriginalShoutDataInput;
}

export interface ReplyUpdateWithoutOriginalShoutDataInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutRepliesInput>;
}

export interface UserUpdateOneRequiredWithoutRepliesInput {
  create?: Maybe<UserCreateWithoutRepliesInput>;
  update?: Maybe<UserUpdateWithoutRepliesDataInput>;
  upsert?: Maybe<UserUpsertWithoutRepliesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutRepliesDataInput {
  createdShouts?: Maybe<ShoutUpdateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutUpdateManyInput>;
  echoedShouts?: Maybe<EchoUpdateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoUpdateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<NVoidUpdateManyInput>;
  currentLocationGeohash?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
}

export interface EchoUpdateManyWithoutEchoedByInput {
  create?: Maybe<
    EchoCreateWithoutEchoedByInput[] | EchoCreateWithoutEchoedByInput
  >;
  delete?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  set?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  disconnect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  update?: Maybe<
    | EchoUpdateWithWhereUniqueWithoutEchoedByInput[]
    | EchoUpdateWithWhereUniqueWithoutEchoedByInput
  >;
  upsert?: Maybe<
    | EchoUpsertWithWhereUniqueWithoutEchoedByInput[]
    | EchoUpsertWithWhereUniqueWithoutEchoedByInput
  >;
  deleteMany?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface EchoUpdateWithWhereUniqueWithoutEchoedByInput {
  where: EchoWhereUniqueInput;
  data: EchoUpdateWithoutEchoedByDataInput;
}

export interface EchoUpdateWithoutEchoedByDataInput {
  nvoid?: Maybe<NVoidUpdateOneRequiredWithoutEchosInput>;
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutEchosInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutEchoesInput>;
}

export interface EchoUpsertWithWhereUniqueWithoutEchoedByInput {
  where: EchoWhereUniqueInput;
  update: EchoUpdateWithoutEchoedByDataInput;
  create: EchoCreateWithoutEchoedByInput;
}

export interface EchoScalarWhereInput {
  echoId?: Maybe<ID_Input>;
  echoId_not?: Maybe<ID_Input>;
  echoId_in?: Maybe<ID_Input[] | ID_Input>;
  echoId_not_in?: Maybe<ID_Input[] | ID_Input>;
  echoId_lt?: Maybe<ID_Input>;
  echoId_lte?: Maybe<ID_Input>;
  echoId_gt?: Maybe<ID_Input>;
  echoId_gte?: Maybe<ID_Input>;
  echoId_contains?: Maybe<ID_Input>;
  echoId_not_contains?: Maybe<ID_Input>;
  echoId_starts_with?: Maybe<ID_Input>;
  echoId_not_starts_with?: Maybe<ID_Input>;
  echoId_ends_with?: Maybe<ID_Input>;
  echoId_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
  OR?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
  NOT?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface EchoUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    EchoCreateWithoutCreatedByInput[] | EchoCreateWithoutCreatedByInput
  >;
  delete?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  set?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  disconnect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  update?: Maybe<
    | EchoUpdateWithWhereUniqueWithoutCreatedByInput[]
    | EchoUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | EchoUpsertWithWhereUniqueWithoutCreatedByInput[]
    | EchoUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface EchoUpdateWithWhereUniqueWithoutCreatedByInput {
  where: EchoWhereUniqueInput;
  data: EchoUpdateWithoutCreatedByDataInput;
}

export interface EchoUpdateWithoutCreatedByDataInput {
  nvoid?: Maybe<NVoidUpdateOneRequiredWithoutEchosInput>;
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutEchosInput>;
  echoedBy?: Maybe<UserUpdateOneRequiredWithoutEchoedShoutsInput>;
}

export interface UserUpdateOneRequiredWithoutEchoedShoutsInput {
  create?: Maybe<UserCreateWithoutEchoedShoutsInput>;
  update?: Maybe<UserUpdateWithoutEchoedShoutsDataInput>;
  upsert?: Maybe<UserUpsertWithoutEchoedShoutsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEchoedShoutsDataInput {
  createdShouts?: Maybe<ShoutUpdateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutUpdateManyInput>;
  echoes?: Maybe<EchoUpdateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<NVoidUpdateManyInput>;
  currentLocationGeohash?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  replies?: Maybe<ReplyUpdateManyWithoutPostedByInput>;
}

export interface NVoidUpdateManyInput {
  create?: Maybe<NVoidCreateInput[] | NVoidCreateInput>;
  update?: Maybe<
    | NVoidUpdateWithWhereUniqueNestedInput[]
    | NVoidUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | NVoidUpsertWithWhereUniqueNestedInput[]
    | NVoidUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<NVoidWhereUniqueInput[] | NVoidWhereUniqueInput>;
  connect?: Maybe<NVoidWhereUniqueInput[] | NVoidWhereUniqueInput>;
  set?: Maybe<NVoidWhereUniqueInput[] | NVoidWhereUniqueInput>;
  disconnect?: Maybe<NVoidWhereUniqueInput[] | NVoidWhereUniqueInput>;
  deleteMany?: Maybe<NVoidScalarWhereInput[] | NVoidScalarWhereInput>;
  updateMany?: Maybe<
    NVoidUpdateManyWithWhereNestedInput[] | NVoidUpdateManyWithWhereNestedInput
  >;
}

export interface NVoidUpdateWithWhereUniqueNestedInput {
  where: NVoidWhereUniqueInput;
  data: NVoidUpdateDataInput;
}

export interface NVoidUpdateDataInput {
  geohash?: Maybe<String>;
  shouts?: Maybe<ShoutUpdateManyWithoutNvoidInput>;
  echos?: Maybe<EchoUpdateManyWithoutNvoidInput>;
}

export interface NVoidUpsertWithWhereUniqueNestedInput {
  where: NVoidWhereUniqueInput;
  update: NVoidUpdateDataInput;
  create: NVoidCreateInput;
}

export interface NVoidScalarWhereInput {
  nvoidId?: Maybe<ID_Input>;
  nvoidId_not?: Maybe<ID_Input>;
  nvoidId_in?: Maybe<ID_Input[] | ID_Input>;
  nvoidId_not_in?: Maybe<ID_Input[] | ID_Input>;
  nvoidId_lt?: Maybe<ID_Input>;
  nvoidId_lte?: Maybe<ID_Input>;
  nvoidId_gt?: Maybe<ID_Input>;
  nvoidId_gte?: Maybe<ID_Input>;
  nvoidId_contains?: Maybe<ID_Input>;
  nvoidId_not_contains?: Maybe<ID_Input>;
  nvoidId_starts_with?: Maybe<ID_Input>;
  nvoidId_not_starts_with?: Maybe<ID_Input>;
  nvoidId_ends_with?: Maybe<ID_Input>;
  nvoidId_not_ends_with?: Maybe<ID_Input>;
  geohash?: Maybe<String>;
  geohash_not?: Maybe<String>;
  geohash_in?: Maybe<String[] | String>;
  geohash_not_in?: Maybe<String[] | String>;
  geohash_lt?: Maybe<String>;
  geohash_lte?: Maybe<String>;
  geohash_gt?: Maybe<String>;
  geohash_gte?: Maybe<String>;
  geohash_contains?: Maybe<String>;
  geohash_not_contains?: Maybe<String>;
  geohash_starts_with?: Maybe<String>;
  geohash_not_starts_with?: Maybe<String>;
  geohash_ends_with?: Maybe<String>;
  geohash_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NVoidScalarWhereInput[] | NVoidScalarWhereInput>;
  OR?: Maybe<NVoidScalarWhereInput[] | NVoidScalarWhereInput>;
  NOT?: Maybe<NVoidScalarWhereInput[] | NVoidScalarWhereInput>;
}

export interface NVoidUpdateManyWithWhereNestedInput {
  where: NVoidScalarWhereInput;
  data: NVoidUpdateManyDataInput;
}

export interface NVoidUpdateManyDataInput {
  geohash?: Maybe<String>;
}

export interface ReplyUpdateManyWithoutPostedByInput {
  create?: Maybe<
    ReplyCreateWithoutPostedByInput[] | ReplyCreateWithoutPostedByInput
  >;
  delete?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  connect?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  set?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  disconnect?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  update?: Maybe<
    | ReplyUpdateWithWhereUniqueWithoutPostedByInput[]
    | ReplyUpdateWithWhereUniqueWithoutPostedByInput
  >;
  upsert?: Maybe<
    | ReplyUpsertWithWhereUniqueWithoutPostedByInput[]
    | ReplyUpsertWithWhereUniqueWithoutPostedByInput
  >;
  deleteMany?: Maybe<ReplyScalarWhereInput[] | ReplyScalarWhereInput>;
  updateMany?: Maybe<
    ReplyUpdateManyWithWhereNestedInput[] | ReplyUpdateManyWithWhereNestedInput
  >;
}

export interface ReplyUpdateWithWhereUniqueWithoutPostedByInput {
  where: ReplyWhereUniqueInput;
  data: ReplyUpdateWithoutPostedByDataInput;
}

export interface ReplyUpdateWithoutPostedByDataInput {
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutRepliesInput>;
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
}

export interface ShoutUpdateOneRequiredWithoutRepliesInput {
  create?: Maybe<ShoutCreateWithoutRepliesInput>;
  update?: Maybe<ShoutUpdateWithoutRepliesDataInput>;
  upsert?: Maybe<ShoutUpsertWithoutRepliesInput>;
  connect?: Maybe<ShoutWhereUniqueInput>;
}

export interface ShoutUpdateWithoutRepliesDataInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCreatedShoutsInput>;
  echos?: Maybe<EchoUpdateManyWithoutOriginalShoutInput>;
  nvoid?: Maybe<NVoidUpdateOneRequiredWithoutShoutsInput>;
}

export interface ShoutUpsertWithoutRepliesInput {
  update: ShoutUpdateWithoutRepliesDataInput;
  create: ShoutCreateWithoutRepliesInput;
}

export interface ReplyUpsertWithWhereUniqueWithoutPostedByInput {
  where: ReplyWhereUniqueInput;
  update: ReplyUpdateWithoutPostedByDataInput;
  create: ReplyCreateWithoutPostedByInput;
}

export interface ReplyScalarWhereInput {
  voteCount?: Maybe<Int>;
  voteCount_not?: Maybe<Int>;
  voteCount_in?: Maybe<Int[] | Int>;
  voteCount_not_in?: Maybe<Int[] | Int>;
  voteCount_lt?: Maybe<Int>;
  voteCount_lte?: Maybe<Int>;
  voteCount_gt?: Maybe<Int>;
  voteCount_gte?: Maybe<Int>;
  replyId?: Maybe<ID_Input>;
  replyId_not?: Maybe<ID_Input>;
  replyId_in?: Maybe<ID_Input[] | ID_Input>;
  replyId_not_in?: Maybe<ID_Input[] | ID_Input>;
  replyId_lt?: Maybe<ID_Input>;
  replyId_lte?: Maybe<ID_Input>;
  replyId_gt?: Maybe<ID_Input>;
  replyId_gte?: Maybe<ID_Input>;
  replyId_contains?: Maybe<ID_Input>;
  replyId_not_contains?: Maybe<ID_Input>;
  replyId_starts_with?: Maybe<ID_Input>;
  replyId_not_starts_with?: Maybe<ID_Input>;
  replyId_ends_with?: Maybe<ID_Input>;
  replyId_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<ReplyScalarWhereInput[] | ReplyScalarWhereInput>;
  OR?: Maybe<ReplyScalarWhereInput[] | ReplyScalarWhereInput>;
  NOT?: Maybe<ReplyScalarWhereInput[] | ReplyScalarWhereInput>;
}

export interface ReplyUpdateManyWithWhereNestedInput {
  where: ReplyScalarWhereInput;
  data: ReplyUpdateManyDataInput;
}

export interface ReplyUpdateManyDataInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
}

export interface UserUpsertWithoutEchoedShoutsInput {
  update: UserUpdateWithoutEchoedShoutsDataInput;
  create: UserCreateWithoutEchoedShoutsInput;
}

export interface EchoUpsertWithWhereUniqueWithoutCreatedByInput {
  where: EchoWhereUniqueInput;
  update: EchoUpdateWithoutCreatedByDataInput;
  create: EchoCreateWithoutCreatedByInput;
}

export interface UserUpsertWithoutRepliesInput {
  update: UserUpdateWithoutRepliesDataInput;
  create: UserCreateWithoutRepliesInput;
}

export interface ReplyUpsertWithWhereUniqueWithoutOriginalShoutInput {
  where: ReplyWhereUniqueInput;
  update: ReplyUpdateWithoutOriginalShoutDataInput;
  create: ReplyCreateWithoutOriginalShoutInput;
}

export interface ShoutUpsertWithoutEchosInput {
  update: ShoutUpdateWithoutEchosDataInput;
  create: ShoutCreateWithoutEchosInput;
}

export interface EchoUpsertWithWhereUniqueWithoutNvoidInput {
  where: EchoWhereUniqueInput;
  update: EchoUpdateWithoutNvoidDataInput;
  create: EchoCreateWithoutNvoidInput;
}

export interface NVoidUpsertWithoutShoutsInput {
  update: NVoidUpdateWithoutShoutsDataInput;
  create: NVoidCreateWithoutShoutsInput;
}

export interface ShoutUpsertWithWhereUniqueWithoutPostedByInput {
  where: ShoutWhereUniqueInput;
  update: ShoutUpdateWithoutPostedByDataInput;
  create: ShoutCreateWithoutPostedByInput;
}

export interface ShoutScalarWhereInput {
  voteCount?: Maybe<Int>;
  voteCount_not?: Maybe<Int>;
  voteCount_in?: Maybe<Int[] | Int>;
  voteCount_not_in?: Maybe<Int[] | Int>;
  voteCount_lt?: Maybe<Int>;
  voteCount_lte?: Maybe<Int>;
  voteCount_gt?: Maybe<Int>;
  voteCount_gte?: Maybe<Int>;
  shoutId?: Maybe<ID_Input>;
  shoutId_not?: Maybe<ID_Input>;
  shoutId_in?: Maybe<ID_Input[] | ID_Input>;
  shoutId_not_in?: Maybe<ID_Input[] | ID_Input>;
  shoutId_lt?: Maybe<ID_Input>;
  shoutId_lte?: Maybe<ID_Input>;
  shoutId_gt?: Maybe<ID_Input>;
  shoutId_gte?: Maybe<ID_Input>;
  shoutId_contains?: Maybe<ID_Input>;
  shoutId_not_contains?: Maybe<ID_Input>;
  shoutId_starts_with?: Maybe<ID_Input>;
  shoutId_not_starts_with?: Maybe<ID_Input>;
  shoutId_ends_with?: Maybe<ID_Input>;
  shoutId_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  OR?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  NOT?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
}

export interface ShoutUpdateManyWithWhereNestedInput {
  where: ShoutScalarWhereInput;
  data: ShoutUpdateManyDataInput;
}

export interface ShoutUpdateManyDataInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
}

export interface UserUpsertWithoutEchoesInput {
  update: UserUpdateWithoutEchoesDataInput;
  create: UserCreateWithoutEchoesInput;
}

export interface EchoUpsertWithWhereUniqueWithoutOriginalShoutInput {
  where: EchoWhereUniqueInput;
  update: EchoUpdateWithoutOriginalShoutDataInput;
  create: EchoCreateWithoutOriginalShoutInput;
}

export interface ShoutUpsertWithWhereUniqueNestedInput {
  where: ShoutWhereUniqueInput;
  update: ShoutUpdateDataInput;
  create: ShoutCreateInput;
}

export interface UserUpsertWithoutCreatedShoutsInput {
  update: UserUpdateWithoutCreatedShoutsDataInput;
  create: UserCreateWithoutCreatedShoutsInput;
}

export interface ShoutUpsertWithWhereUniqueWithoutNvoidInput {
  where: ShoutWhereUniqueInput;
  update: ShoutUpdateWithoutNvoidDataInput;
  create: ShoutCreateWithoutNvoidInput;
}

export interface NVoidUpsertWithoutEchosInput {
  update: NVoidUpdateWithoutEchosDataInput;
  create: NVoidCreateWithoutEchosInput;
}

export interface NVoidUpdateInput {
  geohash?: Maybe<String>;
  shouts?: Maybe<ShoutUpdateManyWithoutNvoidInput>;
  echos?: Maybe<EchoUpdateManyWithoutNvoidInput>;
}

export interface NVoidUpdateManyMutationInput {
  geohash?: Maybe<String>;
}

export interface ReplyCreateInput {
  originalShout: ShoutCreateOneWithoutRepliesInput;
  voteCount: Int;
  replyId?: Maybe<ID_Input>;
  content: String;
  postedBy: UserCreateOneWithoutRepliesInput;
}

export interface ReplyUpdateInput {
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutRepliesInput>;
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutRepliesInput>;
}

export interface ReplyUpdateManyMutationInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
}

export interface ShoutUpdateInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCreatedShoutsInput>;
  echos?: Maybe<EchoUpdateManyWithoutOriginalShoutInput>;
  nvoid?: Maybe<NVoidUpdateOneRequiredWithoutShoutsInput>;
  replies?: Maybe<ReplyUpdateManyWithoutOriginalShoutInput>;
}

export interface ShoutUpdateManyMutationInput {
  voteCount?: Maybe<Int>;
  content?: Maybe<String>;
}

export interface UserCreateInput {
  userId?: Maybe<ID_Input>;
  createdShouts?: Maybe<ShoutCreateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutCreateManyInput>;
  echoedShouts?: Maybe<EchoCreateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoCreateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<NVoidCreateManyInput>;
  currentLocationGeohash: String;
  username: String;
  password: String;
  replies?: Maybe<ReplyCreateManyWithoutPostedByInput>;
}

export interface UserUpdateInput {
  createdShouts?: Maybe<ShoutUpdateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutUpdateManyInput>;
  echoedShouts?: Maybe<EchoUpdateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoUpdateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<NVoidUpdateManyInput>;
  currentLocationGeohash?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
  replies?: Maybe<ReplyUpdateManyWithoutPostedByInput>;
}

export interface UserUpdateManyMutationInput {
  currentLocationGeohash?: Maybe<String>;
  username?: Maybe<String>;
  password?: Maybe<String>;
}

export interface EchoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EchoWhereInput>;
  AND?: Maybe<EchoSubscriptionWhereInput[] | EchoSubscriptionWhereInput>;
  OR?: Maybe<EchoSubscriptionWhereInput[] | EchoSubscriptionWhereInput>;
  NOT?: Maybe<EchoSubscriptionWhereInput[] | EchoSubscriptionWhereInput>;
}

export interface NVoidSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NVoidWhereInput>;
  AND?: Maybe<NVoidSubscriptionWhereInput[] | NVoidSubscriptionWhereInput>;
  OR?: Maybe<NVoidSubscriptionWhereInput[] | NVoidSubscriptionWhereInput>;
  NOT?: Maybe<NVoidSubscriptionWhereInput[] | NVoidSubscriptionWhereInput>;
}

export interface ReplySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReplyWhereInput>;
  AND?: Maybe<ReplySubscriptionWhereInput[] | ReplySubscriptionWhereInput>;
  OR?: Maybe<ReplySubscriptionWhereInput[] | ReplySubscriptionWhereInput>;
  NOT?: Maybe<ReplySubscriptionWhereInput[] | ReplySubscriptionWhereInput>;
}

export interface ShoutSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShoutWhereInput>;
  AND?: Maybe<ShoutSubscriptionWhereInput[] | ShoutSubscriptionWhereInput>;
  OR?: Maybe<ShoutSubscriptionWhereInput[] | ShoutSubscriptionWhereInput>;
  NOT?: Maybe<ShoutSubscriptionWhereInput[] | ShoutSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Echo {
  echoId: ID_Output;
  createdAt: DateTimeOutput;
}

export interface EchoPromise extends Promise<Echo>, Fragmentable {
  echoId: () => Promise<ID_Output>;
  nvoid: <T = NVoidPromise>() => T;
  originalShout: <T = ShoutPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  echoedBy: <T = UserPromise>() => T;
}

export interface EchoSubscription
  extends Promise<AsyncIterator<Echo>>,
    Fragmentable {
  echoId: () => Promise<AsyncIterator<ID_Output>>;
  nvoid: <T = NVoidSubscription>() => T;
  originalShout: <T = ShoutSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
  echoedBy: <T = UserSubscription>() => T;
}

export interface EchoNullablePromise
  extends Promise<Echo | null>,
    Fragmentable {
  echoId: () => Promise<ID_Output>;
  nvoid: <T = NVoidPromise>() => T;
  originalShout: <T = ShoutPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  echoedBy: <T = UserPromise>() => T;
}

export interface NVoid {
  nvoidId: ID_Output;
  geohash: String;
  createdAt: DateTimeOutput;
}

export interface NVoidPromise extends Promise<NVoid>, Fragmentable {
  nvoidId: () => Promise<ID_Output>;
  geohash: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  shouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echos: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NVoidSubscription
  extends Promise<AsyncIterator<NVoid>>,
    Fragmentable {
  nvoidId: () => Promise<AsyncIterator<ID_Output>>;
  geohash: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  shouts: <T = Promise<AsyncIterator<ShoutSubscription>>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echos: <T = Promise<AsyncIterator<EchoSubscription>>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NVoidNullablePromise
  extends Promise<NVoid | null>,
    Fragmentable {
  nvoidId: () => Promise<ID_Output>;
  geohash: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  shouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echos: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Shout {
  voteCount: Int;
  shoutId: ID_Output;
  createdAt: DateTimeOutput;
  content: String;
}

export interface ShoutPromise extends Promise<Shout>, Fragmentable {
  voteCount: () => Promise<Int>;
  shoutId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  postedBy: <T = UserPromise>() => T;
  echos: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  nvoid: <T = NVoidPromise>() => T;
  replies: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ShoutSubscription
  extends Promise<AsyncIterator<Shout>>,
    Fragmentable {
  voteCount: () => Promise<AsyncIterator<Int>>;
  shoutId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  postedBy: <T = UserSubscription>() => T;
  echos: <T = Promise<AsyncIterator<EchoSubscription>>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  nvoid: <T = NVoidSubscription>() => T;
  replies: <T = Promise<AsyncIterator<ReplySubscription>>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ShoutNullablePromise
  extends Promise<Shout | null>,
    Fragmentable {
  voteCount: () => Promise<Int>;
  shoutId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  postedBy: <T = UserPromise>() => T;
  echos: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  nvoid: <T = NVoidPromise>() => T;
  replies: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface User {
  createdAt: DateTimeOutput;
  userId: ID_Output;
  currentLocationGeohash: String;
  username: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
  createdShouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedShouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoedShouts: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoes: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedVoids: <T = FragmentableArray<NVoid>>(args?: {
    where?: NVoidWhereInput;
    orderBy?: NVoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  currentLocationGeohash: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  replies: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  createdShouts: <T = Promise<AsyncIterator<ShoutSubscription>>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedShouts: <T = Promise<AsyncIterator<ShoutSubscription>>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoedShouts: <T = Promise<AsyncIterator<EchoSubscription>>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoes: <T = Promise<AsyncIterator<EchoSubscription>>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedVoids: <T = Promise<AsyncIterator<NVoidSubscription>>>(args?: {
    where?: NVoidWhereInput;
    orderBy?: NVoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  currentLocationGeohash: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  replies: <T = Promise<AsyncIterator<ReplySubscription>>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
  createdShouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedShouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoedShouts: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoes: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedVoids: <T = FragmentableArray<NVoid>>(args?: {
    where?: NVoidWhereInput;
    orderBy?: NVoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  currentLocationGeohash: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  replies: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Reply {
  voteCount: Int;
  replyId: ID_Output;
  createdAt: DateTimeOutput;
  content: String;
}

export interface ReplyPromise extends Promise<Reply>, Fragmentable {
  originalShout: <T = ShoutPromise>() => T;
  voteCount: () => Promise<Int>;
  replyId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  postedBy: <T = UserPromise>() => T;
}

export interface ReplySubscription
  extends Promise<AsyncIterator<Reply>>,
    Fragmentable {
  originalShout: <T = ShoutSubscription>() => T;
  voteCount: () => Promise<AsyncIterator<Int>>;
  replyId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  postedBy: <T = UserSubscription>() => T;
}

export interface ReplyNullablePromise
  extends Promise<Reply | null>,
    Fragmentable {
  originalShout: <T = ShoutPromise>() => T;
  voteCount: () => Promise<Int>;
  replyId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  postedBy: <T = UserPromise>() => T;
}

export interface EchoConnection {
  pageInfo: PageInfo;
  edges: EchoEdge[];
}

export interface EchoConnectionPromise
  extends Promise<EchoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EchoEdge>>() => T;
  aggregate: <T = AggregateEchoPromise>() => T;
}

export interface EchoConnectionSubscription
  extends Promise<AsyncIterator<EchoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EchoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEchoSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface EchoEdge {
  node: Echo;
  cursor: String;
}

export interface EchoEdgePromise extends Promise<EchoEdge>, Fragmentable {
  node: <T = EchoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EchoEdgeSubscription
  extends Promise<AsyncIterator<EchoEdge>>,
    Fragmentable {
  node: <T = EchoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEcho {
  count: Int;
}

export interface AggregateEchoPromise
  extends Promise<AggregateEcho>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEchoSubscription
  extends Promise<AsyncIterator<AggregateEcho>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NVoidConnection {
  pageInfo: PageInfo;
  edges: NVoidEdge[];
}

export interface NVoidConnectionPromise
  extends Promise<NVoidConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NVoidEdge>>() => T;
  aggregate: <T = AggregateNVoidPromise>() => T;
}

export interface NVoidConnectionSubscription
  extends Promise<AsyncIterator<NVoidConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NVoidEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNVoidSubscription>() => T;
}

export interface NVoidEdge {
  node: NVoid;
  cursor: String;
}

export interface NVoidEdgePromise extends Promise<NVoidEdge>, Fragmentable {
  node: <T = NVoidPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NVoidEdgeSubscription
  extends Promise<AsyncIterator<NVoidEdge>>,
    Fragmentable {
  node: <T = NVoidSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNVoid {
  count: Int;
}

export interface AggregateNVoidPromise
  extends Promise<AggregateNVoid>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNVoidSubscription
  extends Promise<AsyncIterator<AggregateNVoid>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReplyConnection {
  pageInfo: PageInfo;
  edges: ReplyEdge[];
}

export interface ReplyConnectionPromise
  extends Promise<ReplyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReplyEdge>>() => T;
  aggregate: <T = AggregateReplyPromise>() => T;
}

export interface ReplyConnectionSubscription
  extends Promise<AsyncIterator<ReplyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReplyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReplySubscription>() => T;
}

export interface ReplyEdge {
  node: Reply;
  cursor: String;
}

export interface ReplyEdgePromise extends Promise<ReplyEdge>, Fragmentable {
  node: <T = ReplyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReplyEdgeSubscription
  extends Promise<AsyncIterator<ReplyEdge>>,
    Fragmentable {
  node: <T = ReplySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReply {
  count: Int;
}

export interface AggregateReplyPromise
  extends Promise<AggregateReply>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReplySubscription
  extends Promise<AsyncIterator<AggregateReply>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShoutConnection {
  pageInfo: PageInfo;
  edges: ShoutEdge[];
}

export interface ShoutConnectionPromise
  extends Promise<ShoutConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShoutEdge>>() => T;
  aggregate: <T = AggregateShoutPromise>() => T;
}

export interface ShoutConnectionSubscription
  extends Promise<AsyncIterator<ShoutConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShoutEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShoutSubscription>() => T;
}

export interface ShoutEdge {
  node: Shout;
  cursor: String;
}

export interface ShoutEdgePromise extends Promise<ShoutEdge>, Fragmentable {
  node: <T = ShoutPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShoutEdgeSubscription
  extends Promise<AsyncIterator<ShoutEdge>>,
    Fragmentable {
  node: <T = ShoutSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShout {
  count: Int;
}

export interface AggregateShoutPromise
  extends Promise<AggregateShout>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShoutSubscription
  extends Promise<AsyncIterator<AggregateShout>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface EchoSubscriptionPayload {
  mutation: MutationType;
  node: Echo;
  updatedFields: String[];
  previousValues: EchoPreviousValues;
}

export interface EchoSubscriptionPayloadPromise
  extends Promise<EchoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EchoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EchoPreviousValuesPromise>() => T;
}

export interface EchoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EchoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EchoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EchoPreviousValuesSubscription>() => T;
}

export interface EchoPreviousValues {
  echoId: ID_Output;
  createdAt: DateTimeOutput;
}

export interface EchoPreviousValuesPromise
  extends Promise<EchoPreviousValues>,
    Fragmentable {
  echoId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface EchoPreviousValuesSubscription
  extends Promise<AsyncIterator<EchoPreviousValues>>,
    Fragmentable {
  echoId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NVoidSubscriptionPayload {
  mutation: MutationType;
  node: NVoid;
  updatedFields: String[];
  previousValues: NVoidPreviousValues;
}

export interface NVoidSubscriptionPayloadPromise
  extends Promise<NVoidSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NVoidPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NVoidPreviousValuesPromise>() => T;
}

export interface NVoidSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NVoidSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NVoidSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NVoidPreviousValuesSubscription>() => T;
}

export interface NVoidPreviousValues {
  nvoidId: ID_Output;
  geohash: String;
  createdAt: DateTimeOutput;
}

export interface NVoidPreviousValuesPromise
  extends Promise<NVoidPreviousValues>,
    Fragmentable {
  nvoidId: () => Promise<ID_Output>;
  geohash: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface NVoidPreviousValuesSubscription
  extends Promise<AsyncIterator<NVoidPreviousValues>>,
    Fragmentable {
  nvoidId: () => Promise<AsyncIterator<ID_Output>>;
  geohash: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReplySubscriptionPayload {
  mutation: MutationType;
  node: Reply;
  updatedFields: String[];
  previousValues: ReplyPreviousValues;
}

export interface ReplySubscriptionPayloadPromise
  extends Promise<ReplySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReplyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReplyPreviousValuesPromise>() => T;
}

export interface ReplySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReplySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReplySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReplyPreviousValuesSubscription>() => T;
}

export interface ReplyPreviousValues {
  voteCount: Int;
  replyId: ID_Output;
  createdAt: DateTimeOutput;
  content: String;
}

export interface ReplyPreviousValuesPromise
  extends Promise<ReplyPreviousValues>,
    Fragmentable {
  voteCount: () => Promise<Int>;
  replyId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface ReplyPreviousValuesSubscription
  extends Promise<AsyncIterator<ReplyPreviousValues>>,
    Fragmentable {
  voteCount: () => Promise<AsyncIterator<Int>>;
  replyId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface ShoutSubscriptionPayload {
  mutation: MutationType;
  node: Shout;
  updatedFields: String[];
  previousValues: ShoutPreviousValues;
}

export interface ShoutSubscriptionPayloadPromise
  extends Promise<ShoutSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShoutPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShoutPreviousValuesPromise>() => T;
}

export interface ShoutSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShoutSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShoutSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShoutPreviousValuesSubscription>() => T;
}

export interface ShoutPreviousValues {
  voteCount: Int;
  shoutId: ID_Output;
  createdAt: DateTimeOutput;
  content: String;
}

export interface ShoutPreviousValuesPromise
  extends Promise<ShoutPreviousValues>,
    Fragmentable {
  voteCount: () => Promise<Int>;
  shoutId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface ShoutPreviousValuesSubscription
  extends Promise<AsyncIterator<ShoutPreviousValues>>,
    Fragmentable {
  voteCount: () => Promise<AsyncIterator<Int>>;
  shoutId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  createdAt: DateTimeOutput;
  userId: ID_Output;
  currentLocationGeohash: String;
  username: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
  currentLocationGeohash: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  currentLocationGeohash: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Shout",
    embedded: false
  },
  {
    name: "Reply",
    embedded: false
  },
  {
    name: "Echo",
    embedded: false
  },
  {
    name: "NVoid",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
