// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  echo: (where?: EchoWhereInput) => Promise<boolean>;
  shout: (where?: ShoutWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  void: (where?: VoidWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  echo: (where: EchoWhereUniqueInput) => EchoNullablePromise;
  echoes: (args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Echo>;
  echoesConnection: (args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EchoConnectionPromise;
  shout: (where: ShoutWhereUniqueInput) => ShoutNullablePromise;
  shouts: (args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Shout>;
  shoutsConnection: (args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShoutConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  void: (where: VoidWhereUniqueInput) => VoidNullablePromise;
  voids: (args?: {
    where?: VoidWhereInput;
    orderBy?: VoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Void>;
  voidsConnection: (args?: {
    where?: VoidWhereInput;
    orderBy?: VoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VoidConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createEcho: (data: EchoCreateInput) => EchoPromise;
  updateEcho: (args: {
    data: EchoUpdateInput;
    where: EchoWhereUniqueInput;
  }) => EchoPromise;
  upsertEcho: (args: {
    where: EchoWhereUniqueInput;
    create: EchoCreateInput;
    update: EchoUpdateInput;
  }) => EchoPromise;
  deleteEcho: (where: EchoWhereUniqueInput) => EchoPromise;
  deleteManyEchoes: (where?: EchoWhereInput) => BatchPayloadPromise;
  createShout: (data: ShoutCreateInput) => ShoutPromise;
  updateShout: (args: {
    data: ShoutUpdateInput;
    where: ShoutWhereUniqueInput;
  }) => ShoutPromise;
  updateManyShouts: (args: {
    data: ShoutUpdateManyMutationInput;
    where?: ShoutWhereInput;
  }) => BatchPayloadPromise;
  upsertShout: (args: {
    where: ShoutWhereUniqueInput;
    create: ShoutCreateInput;
    update: ShoutUpdateInput;
  }) => ShoutPromise;
  deleteShout: (where: ShoutWhereUniqueInput) => ShoutPromise;
  deleteManyShouts: (where?: ShoutWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVoid: (data: VoidCreateInput) => VoidPromise;
  updateVoid: (args: {
    data: VoidUpdateInput;
    where: VoidWhereUniqueInput;
  }) => VoidPromise;
  updateManyVoids: (args: {
    data: VoidUpdateManyMutationInput;
    where?: VoidWhereInput;
  }) => BatchPayloadPromise;
  upsertVoid: (args: {
    where: VoidWhereUniqueInput;
    create: VoidCreateInput;
    update: VoidUpdateInput;
  }) => VoidPromise;
  deleteVoid: (where: VoidWhereUniqueInput) => VoidPromise;
  deleteManyVoids: (where?: VoidWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  echo: (
    where?: EchoSubscriptionWhereInput
  ) => EchoSubscriptionPayloadSubscription;
  shout: (
    where?: ShoutSubscriptionWhereInput
  ) => ShoutSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  void: (
    where?: VoidSubscriptionWhereInput
  ) => VoidSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ShoutOrderByInput =
  | "voteCount_ASC"
  | "voteCount_DESC"
  | "shoutId_ASC"
  | "shoutId_DESC"
  | "geohash_ASC"
  | "geohash_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "content_ASC"
  | "content_DESC";

export type EchoOrderByInput =
  | "echoId_ASC"
  | "echoId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type VoidOrderByInput =
  | "voidId_ASC"
  | "voidId_DESC"
  | "geohash_ASC"
  | "geohash_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type UserOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "localVoidGeohash_ASC"
  | "localVoidGeohash_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type EchoWhereUniqueInput = AtLeastOne<{
  echoId: Maybe<ID_Input>;
}>;

export interface ShoutWhereInput {
  voteCount?: Maybe<Int>;
  voteCount_not?: Maybe<Int>;
  voteCount_in?: Maybe<Int[] | Int>;
  voteCount_not_in?: Maybe<Int[] | Int>;
  voteCount_lt?: Maybe<Int>;
  voteCount_lte?: Maybe<Int>;
  voteCount_gt?: Maybe<Int>;
  voteCount_gte?: Maybe<Int>;
  shoutId?: Maybe<ID_Input>;
  shoutId_not?: Maybe<ID_Input>;
  shoutId_in?: Maybe<ID_Input[] | ID_Input>;
  shoutId_not_in?: Maybe<ID_Input[] | ID_Input>;
  shoutId_lt?: Maybe<ID_Input>;
  shoutId_lte?: Maybe<ID_Input>;
  shoutId_gt?: Maybe<ID_Input>;
  shoutId_gte?: Maybe<ID_Input>;
  shoutId_contains?: Maybe<ID_Input>;
  shoutId_not_contains?: Maybe<ID_Input>;
  shoutId_starts_with?: Maybe<ID_Input>;
  shoutId_not_starts_with?: Maybe<ID_Input>;
  shoutId_ends_with?: Maybe<ID_Input>;
  shoutId_not_ends_with?: Maybe<ID_Input>;
  geohash?: Maybe<String>;
  geohash_not?: Maybe<String>;
  geohash_in?: Maybe<String[] | String>;
  geohash_not_in?: Maybe<String[] | String>;
  geohash_lt?: Maybe<String>;
  geohash_lte?: Maybe<String>;
  geohash_gt?: Maybe<String>;
  geohash_gte?: Maybe<String>;
  geohash_contains?: Maybe<String>;
  geohash_not_contains?: Maybe<String>;
  geohash_starts_with?: Maybe<String>;
  geohash_not_starts_with?: Maybe<String>;
  geohash_ends_with?: Maybe<String>;
  geohash_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  postedBy?: Maybe<UserWhereInput>;
  echos_every?: Maybe<EchoWhereInput>;
  echos_some?: Maybe<EchoWhereInput>;
  echos_none?: Maybe<EchoWhereInput>;
  void?: Maybe<VoidWhereInput>;
  AND?: Maybe<ShoutWhereInput[] | ShoutWhereInput>;
  OR?: Maybe<ShoutWhereInput[] | ShoutWhereInput>;
  NOT?: Maybe<ShoutWhereInput[] | ShoutWhereInput>;
}

export interface UserWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  userId?: Maybe<ID_Input>;
  userId_not?: Maybe<ID_Input>;
  userId_in?: Maybe<ID_Input[] | ID_Input>;
  userId_not_in?: Maybe<ID_Input[] | ID_Input>;
  userId_lt?: Maybe<ID_Input>;
  userId_lte?: Maybe<ID_Input>;
  userId_gt?: Maybe<ID_Input>;
  userId_gte?: Maybe<ID_Input>;
  userId_contains?: Maybe<ID_Input>;
  userId_not_contains?: Maybe<ID_Input>;
  userId_starts_with?: Maybe<ID_Input>;
  userId_not_starts_with?: Maybe<ID_Input>;
  userId_ends_with?: Maybe<ID_Input>;
  userId_not_ends_with?: Maybe<ID_Input>;
  createdShouts_every?: Maybe<ShoutWhereInput>;
  createdShouts_some?: Maybe<ShoutWhereInput>;
  createdShouts_none?: Maybe<ShoutWhereInput>;
  savedShouts_every?: Maybe<ShoutWhereInput>;
  savedShouts_some?: Maybe<ShoutWhereInput>;
  savedShouts_none?: Maybe<ShoutWhereInput>;
  echoedShouts_every?: Maybe<EchoWhereInput>;
  echoedShouts_some?: Maybe<EchoWhereInput>;
  echoedShouts_none?: Maybe<EchoWhereInput>;
  echoes_every?: Maybe<EchoWhereInput>;
  echoes_some?: Maybe<EchoWhereInput>;
  echoes_none?: Maybe<EchoWhereInput>;
  savedVoids_every?: Maybe<VoidWhereInput>;
  savedVoids_some?: Maybe<VoidWhereInput>;
  savedVoids_none?: Maybe<VoidWhereInput>;
  localVoidGeohash?: Maybe<String>;
  localVoidGeohash_not?: Maybe<String>;
  localVoidGeohash_in?: Maybe<String[] | String>;
  localVoidGeohash_not_in?: Maybe<String[] | String>;
  localVoidGeohash_lt?: Maybe<String>;
  localVoidGeohash_lte?: Maybe<String>;
  localVoidGeohash_gt?: Maybe<String>;
  localVoidGeohash_gte?: Maybe<String>;
  localVoidGeohash_contains?: Maybe<String>;
  localVoidGeohash_not_contains?: Maybe<String>;
  localVoidGeohash_starts_with?: Maybe<String>;
  localVoidGeohash_not_starts_with?: Maybe<String>;
  localVoidGeohash_ends_with?: Maybe<String>;
  localVoidGeohash_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface EchoWhereInput {
  echoId?: Maybe<ID_Input>;
  echoId_not?: Maybe<ID_Input>;
  echoId_in?: Maybe<ID_Input[] | ID_Input>;
  echoId_not_in?: Maybe<ID_Input[] | ID_Input>;
  echoId_lt?: Maybe<ID_Input>;
  echoId_lte?: Maybe<ID_Input>;
  echoId_gt?: Maybe<ID_Input>;
  echoId_gte?: Maybe<ID_Input>;
  echoId_contains?: Maybe<ID_Input>;
  echoId_not_contains?: Maybe<ID_Input>;
  echoId_starts_with?: Maybe<ID_Input>;
  echoId_not_starts_with?: Maybe<ID_Input>;
  echoId_ends_with?: Maybe<ID_Input>;
  echoId_not_ends_with?: Maybe<ID_Input>;
  void?: Maybe<VoidWhereInput>;
  originalShout?: Maybe<ShoutWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserWhereInput>;
  echoedBy?: Maybe<UserWhereInput>;
  AND?: Maybe<EchoWhereInput[] | EchoWhereInput>;
  OR?: Maybe<EchoWhereInput[] | EchoWhereInput>;
  NOT?: Maybe<EchoWhereInput[] | EchoWhereInput>;
}

export interface VoidWhereInput {
  voidId?: Maybe<ID_Input>;
  voidId_not?: Maybe<ID_Input>;
  voidId_in?: Maybe<ID_Input[] | ID_Input>;
  voidId_not_in?: Maybe<ID_Input[] | ID_Input>;
  voidId_lt?: Maybe<ID_Input>;
  voidId_lte?: Maybe<ID_Input>;
  voidId_gt?: Maybe<ID_Input>;
  voidId_gte?: Maybe<ID_Input>;
  voidId_contains?: Maybe<ID_Input>;
  voidId_not_contains?: Maybe<ID_Input>;
  voidId_starts_with?: Maybe<ID_Input>;
  voidId_not_starts_with?: Maybe<ID_Input>;
  voidId_ends_with?: Maybe<ID_Input>;
  voidId_not_ends_with?: Maybe<ID_Input>;
  geohash?: Maybe<String>;
  geohash_not?: Maybe<String>;
  geohash_in?: Maybe<String[] | String>;
  geohash_not_in?: Maybe<String[] | String>;
  geohash_lt?: Maybe<String>;
  geohash_lte?: Maybe<String>;
  geohash_gt?: Maybe<String>;
  geohash_gte?: Maybe<String>;
  geohash_contains?: Maybe<String>;
  geohash_not_contains?: Maybe<String>;
  geohash_starts_with?: Maybe<String>;
  geohash_not_starts_with?: Maybe<String>;
  geohash_ends_with?: Maybe<String>;
  geohash_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  shouts_every?: Maybe<ShoutWhereInput>;
  shouts_some?: Maybe<ShoutWhereInput>;
  shouts_none?: Maybe<ShoutWhereInput>;
  echos_every?: Maybe<EchoWhereInput>;
  echos_some?: Maybe<EchoWhereInput>;
  echos_none?: Maybe<EchoWhereInput>;
  AND?: Maybe<VoidWhereInput[] | VoidWhereInput>;
  OR?: Maybe<VoidWhereInput[] | VoidWhereInput>;
  NOT?: Maybe<VoidWhereInput[] | VoidWhereInput>;
}

export type ShoutWhereUniqueInput = AtLeastOne<{
  shoutId: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  userId: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type VoidWhereUniqueInput = AtLeastOne<{
  voidId: Maybe<ID_Input>;
}>;

export interface EchoCreateInput {
  echoId?: Maybe<ID_Input>;
  void: VoidCreateOneWithoutEchosInput;
  originalShout: ShoutCreateOneWithoutEchosInput;
  createdBy: UserCreateOneWithoutEchoesInput;
  echoedBy: UserCreateOneWithoutEchoedShoutsInput;
}

export interface VoidCreateOneWithoutEchosInput {
  create?: Maybe<VoidCreateWithoutEchosInput>;
  connect?: Maybe<VoidWhereUniqueInput>;
}

export interface VoidCreateWithoutEchosInput {
  voidId?: Maybe<ID_Input>;
  geohash: String;
  shouts?: Maybe<ShoutCreateManyWithoutVoidInput>;
}

export interface ShoutCreateManyWithoutVoidInput {
  create?: Maybe<ShoutCreateWithoutVoidInput[] | ShoutCreateWithoutVoidInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
}

export interface ShoutCreateWithoutVoidInput {
  voteCount: Int;
  shoutId?: Maybe<ID_Input>;
  geohash: String;
  content: String;
  postedBy: UserCreateOneWithoutCreatedShoutsInput;
  echos?: Maybe<EchoCreateManyWithoutOriginalShoutInput>;
}

export interface UserCreateOneWithoutCreatedShoutsInput {
  create?: Maybe<UserCreateWithoutCreatedShoutsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCreatedShoutsInput {
  userId?: Maybe<ID_Input>;
  savedShouts?: Maybe<ShoutCreateManyInput>;
  echoedShouts?: Maybe<EchoCreateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoCreateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<VoidCreateManyInput>;
  localVoidGeohash: String;
  email: String;
  password: String;
}

export interface ShoutCreateManyInput {
  create?: Maybe<ShoutCreateInput[] | ShoutCreateInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
}

export interface ShoutCreateInput {
  voteCount: Int;
  shoutId?: Maybe<ID_Input>;
  geohash: String;
  content: String;
  postedBy: UserCreateOneWithoutCreatedShoutsInput;
  echos?: Maybe<EchoCreateManyWithoutOriginalShoutInput>;
  void: VoidCreateOneWithoutShoutsInput;
}

export interface EchoCreateManyWithoutOriginalShoutInput {
  create?: Maybe<
    EchoCreateWithoutOriginalShoutInput[] | EchoCreateWithoutOriginalShoutInput
  >;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
}

export interface EchoCreateWithoutOriginalShoutInput {
  echoId?: Maybe<ID_Input>;
  void: VoidCreateOneWithoutEchosInput;
  createdBy: UserCreateOneWithoutEchoesInput;
  echoedBy: UserCreateOneWithoutEchoedShoutsInput;
}

export interface UserCreateOneWithoutEchoesInput {
  create?: Maybe<UserCreateWithoutEchoesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEchoesInput {
  userId?: Maybe<ID_Input>;
  createdShouts?: Maybe<ShoutCreateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutCreateManyInput>;
  echoedShouts?: Maybe<EchoCreateManyWithoutEchoedByInput>;
  savedVoids?: Maybe<VoidCreateManyInput>;
  localVoidGeohash: String;
  email: String;
  password: String;
}

export interface ShoutCreateManyWithoutPostedByInput {
  create?: Maybe<
    ShoutCreateWithoutPostedByInput[] | ShoutCreateWithoutPostedByInput
  >;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
}

export interface ShoutCreateWithoutPostedByInput {
  voteCount: Int;
  shoutId?: Maybe<ID_Input>;
  geohash: String;
  content: String;
  echos?: Maybe<EchoCreateManyWithoutOriginalShoutInput>;
  void: VoidCreateOneWithoutShoutsInput;
}

export interface VoidCreateOneWithoutShoutsInput {
  create?: Maybe<VoidCreateWithoutShoutsInput>;
  connect?: Maybe<VoidWhereUniqueInput>;
}

export interface VoidCreateWithoutShoutsInput {
  voidId?: Maybe<ID_Input>;
  geohash: String;
  echos?: Maybe<EchoCreateManyWithoutVoidInput>;
}

export interface EchoCreateManyWithoutVoidInput {
  create?: Maybe<EchoCreateWithoutVoidInput[] | EchoCreateWithoutVoidInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
}

export interface EchoCreateWithoutVoidInput {
  echoId?: Maybe<ID_Input>;
  originalShout: ShoutCreateOneWithoutEchosInput;
  createdBy: UserCreateOneWithoutEchoesInput;
  echoedBy: UserCreateOneWithoutEchoedShoutsInput;
}

export interface ShoutCreateOneWithoutEchosInput {
  create?: Maybe<ShoutCreateWithoutEchosInput>;
  connect?: Maybe<ShoutWhereUniqueInput>;
}

export interface ShoutCreateWithoutEchosInput {
  voteCount: Int;
  shoutId?: Maybe<ID_Input>;
  geohash: String;
  content: String;
  postedBy: UserCreateOneWithoutCreatedShoutsInput;
  void: VoidCreateOneWithoutShoutsInput;
}

export interface UserCreateOneWithoutEchoedShoutsInput {
  create?: Maybe<UserCreateWithoutEchoedShoutsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutEchoedShoutsInput {
  userId?: Maybe<ID_Input>;
  createdShouts?: Maybe<ShoutCreateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutCreateManyInput>;
  echoes?: Maybe<EchoCreateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<VoidCreateManyInput>;
  localVoidGeohash: String;
  email: String;
  password: String;
}

export interface EchoCreateManyWithoutCreatedByInput {
  create?: Maybe<
    EchoCreateWithoutCreatedByInput[] | EchoCreateWithoutCreatedByInput
  >;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
}

export interface EchoCreateWithoutCreatedByInput {
  echoId?: Maybe<ID_Input>;
  void: VoidCreateOneWithoutEchosInput;
  originalShout: ShoutCreateOneWithoutEchosInput;
  echoedBy: UserCreateOneWithoutEchoedShoutsInput;
}

export interface VoidCreateManyInput {
  create?: Maybe<VoidCreateInput[] | VoidCreateInput>;
  connect?: Maybe<VoidWhereUniqueInput[] | VoidWhereUniqueInput>;
}

export interface VoidCreateInput {
  voidId?: Maybe<ID_Input>;
  geohash: String;
  shouts?: Maybe<ShoutCreateManyWithoutVoidInput>;
  echos?: Maybe<EchoCreateManyWithoutVoidInput>;
}

export interface EchoCreateManyWithoutEchoedByInput {
  create?: Maybe<
    EchoCreateWithoutEchoedByInput[] | EchoCreateWithoutEchoedByInput
  >;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
}

export interface EchoCreateWithoutEchoedByInput {
  echoId?: Maybe<ID_Input>;
  void: VoidCreateOneWithoutEchosInput;
  originalShout: ShoutCreateOneWithoutEchosInput;
  createdBy: UserCreateOneWithoutEchoesInput;
}

export interface EchoUpdateInput {
  void?: Maybe<VoidUpdateOneRequiredWithoutEchosInput>;
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutEchosInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutEchoesInput>;
  echoedBy?: Maybe<UserUpdateOneRequiredWithoutEchoedShoutsInput>;
}

export interface VoidUpdateOneRequiredWithoutEchosInput {
  create?: Maybe<VoidCreateWithoutEchosInput>;
  update?: Maybe<VoidUpdateWithoutEchosDataInput>;
  upsert?: Maybe<VoidUpsertWithoutEchosInput>;
  connect?: Maybe<VoidWhereUniqueInput>;
}

export interface VoidUpdateWithoutEchosDataInput {
  geohash?: Maybe<String>;
  shouts?: Maybe<ShoutUpdateManyWithoutVoidInput>;
}

export interface ShoutUpdateManyWithoutVoidInput {
  create?: Maybe<ShoutCreateWithoutVoidInput[] | ShoutCreateWithoutVoidInput>;
  delete?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  set?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  disconnect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  update?: Maybe<
    | ShoutUpdateWithWhereUniqueWithoutVoidInput[]
    | ShoutUpdateWithWhereUniqueWithoutVoidInput
  >;
  upsert?: Maybe<
    | ShoutUpsertWithWhereUniqueWithoutVoidInput[]
    | ShoutUpsertWithWhereUniqueWithoutVoidInput
  >;
  deleteMany?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  updateMany?: Maybe<
    ShoutUpdateManyWithWhereNestedInput[] | ShoutUpdateManyWithWhereNestedInput
  >;
}

export interface ShoutUpdateWithWhereUniqueWithoutVoidInput {
  where: ShoutWhereUniqueInput;
  data: ShoutUpdateWithoutVoidDataInput;
}

export interface ShoutUpdateWithoutVoidDataInput {
  voteCount?: Maybe<Int>;
  geohash?: Maybe<String>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCreatedShoutsInput>;
  echos?: Maybe<EchoUpdateManyWithoutOriginalShoutInput>;
}

export interface UserUpdateOneRequiredWithoutCreatedShoutsInput {
  create?: Maybe<UserCreateWithoutCreatedShoutsInput>;
  update?: Maybe<UserUpdateWithoutCreatedShoutsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCreatedShoutsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCreatedShoutsDataInput {
  savedShouts?: Maybe<ShoutUpdateManyInput>;
  echoedShouts?: Maybe<EchoUpdateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoUpdateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<VoidUpdateManyInput>;
  localVoidGeohash?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface ShoutUpdateManyInput {
  create?: Maybe<ShoutCreateInput[] | ShoutCreateInput>;
  update?: Maybe<
    | ShoutUpdateWithWhereUniqueNestedInput[]
    | ShoutUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ShoutUpsertWithWhereUniqueNestedInput[]
    | ShoutUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  set?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  disconnect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  deleteMany?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  updateMany?: Maybe<
    ShoutUpdateManyWithWhereNestedInput[] | ShoutUpdateManyWithWhereNestedInput
  >;
}

export interface ShoutUpdateWithWhereUniqueNestedInput {
  where: ShoutWhereUniqueInput;
  data: ShoutUpdateDataInput;
}

export interface ShoutUpdateDataInput {
  voteCount?: Maybe<Int>;
  geohash?: Maybe<String>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCreatedShoutsInput>;
  echos?: Maybe<EchoUpdateManyWithoutOriginalShoutInput>;
  void?: Maybe<VoidUpdateOneRequiredWithoutShoutsInput>;
}

export interface EchoUpdateManyWithoutOriginalShoutInput {
  create?: Maybe<
    EchoCreateWithoutOriginalShoutInput[] | EchoCreateWithoutOriginalShoutInput
  >;
  delete?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  set?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  disconnect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  update?: Maybe<
    | EchoUpdateWithWhereUniqueWithoutOriginalShoutInput[]
    | EchoUpdateWithWhereUniqueWithoutOriginalShoutInput
  >;
  upsert?: Maybe<
    | EchoUpsertWithWhereUniqueWithoutOriginalShoutInput[]
    | EchoUpsertWithWhereUniqueWithoutOriginalShoutInput
  >;
  deleteMany?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface EchoUpdateWithWhereUniqueWithoutOriginalShoutInput {
  where: EchoWhereUniqueInput;
  data: EchoUpdateWithoutOriginalShoutDataInput;
}

export interface EchoUpdateWithoutOriginalShoutDataInput {
  void?: Maybe<VoidUpdateOneRequiredWithoutEchosInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutEchoesInput>;
  echoedBy?: Maybe<UserUpdateOneRequiredWithoutEchoedShoutsInput>;
}

export interface UserUpdateOneRequiredWithoutEchoesInput {
  create?: Maybe<UserCreateWithoutEchoesInput>;
  update?: Maybe<UserUpdateWithoutEchoesDataInput>;
  upsert?: Maybe<UserUpsertWithoutEchoesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEchoesDataInput {
  createdShouts?: Maybe<ShoutUpdateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutUpdateManyInput>;
  echoedShouts?: Maybe<EchoUpdateManyWithoutEchoedByInput>;
  savedVoids?: Maybe<VoidUpdateManyInput>;
  localVoidGeohash?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface ShoutUpdateManyWithoutPostedByInput {
  create?: Maybe<
    ShoutCreateWithoutPostedByInput[] | ShoutCreateWithoutPostedByInput
  >;
  delete?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  connect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  set?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  disconnect?: Maybe<ShoutWhereUniqueInput[] | ShoutWhereUniqueInput>;
  update?: Maybe<
    | ShoutUpdateWithWhereUniqueWithoutPostedByInput[]
    | ShoutUpdateWithWhereUniqueWithoutPostedByInput
  >;
  upsert?: Maybe<
    | ShoutUpsertWithWhereUniqueWithoutPostedByInput[]
    | ShoutUpsertWithWhereUniqueWithoutPostedByInput
  >;
  deleteMany?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  updateMany?: Maybe<
    ShoutUpdateManyWithWhereNestedInput[] | ShoutUpdateManyWithWhereNestedInput
  >;
}

export interface ShoutUpdateWithWhereUniqueWithoutPostedByInput {
  where: ShoutWhereUniqueInput;
  data: ShoutUpdateWithoutPostedByDataInput;
}

export interface ShoutUpdateWithoutPostedByDataInput {
  voteCount?: Maybe<Int>;
  geohash?: Maybe<String>;
  content?: Maybe<String>;
  echos?: Maybe<EchoUpdateManyWithoutOriginalShoutInput>;
  void?: Maybe<VoidUpdateOneRequiredWithoutShoutsInput>;
}

export interface VoidUpdateOneRequiredWithoutShoutsInput {
  create?: Maybe<VoidCreateWithoutShoutsInput>;
  update?: Maybe<VoidUpdateWithoutShoutsDataInput>;
  upsert?: Maybe<VoidUpsertWithoutShoutsInput>;
  connect?: Maybe<VoidWhereUniqueInput>;
}

export interface VoidUpdateWithoutShoutsDataInput {
  geohash?: Maybe<String>;
  echos?: Maybe<EchoUpdateManyWithoutVoidInput>;
}

export interface EchoUpdateManyWithoutVoidInput {
  create?: Maybe<EchoCreateWithoutVoidInput[] | EchoCreateWithoutVoidInput>;
  delete?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  set?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  disconnect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  update?: Maybe<
    | EchoUpdateWithWhereUniqueWithoutVoidInput[]
    | EchoUpdateWithWhereUniqueWithoutVoidInput
  >;
  upsert?: Maybe<
    | EchoUpsertWithWhereUniqueWithoutVoidInput[]
    | EchoUpsertWithWhereUniqueWithoutVoidInput
  >;
  deleteMany?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface EchoUpdateWithWhereUniqueWithoutVoidInput {
  where: EchoWhereUniqueInput;
  data: EchoUpdateWithoutVoidDataInput;
}

export interface EchoUpdateWithoutVoidDataInput {
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutEchosInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutEchoesInput>;
  echoedBy?: Maybe<UserUpdateOneRequiredWithoutEchoedShoutsInput>;
}

export interface ShoutUpdateOneRequiredWithoutEchosInput {
  create?: Maybe<ShoutCreateWithoutEchosInput>;
  update?: Maybe<ShoutUpdateWithoutEchosDataInput>;
  upsert?: Maybe<ShoutUpsertWithoutEchosInput>;
  connect?: Maybe<ShoutWhereUniqueInput>;
}

export interface ShoutUpdateWithoutEchosDataInput {
  voteCount?: Maybe<Int>;
  geohash?: Maybe<String>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCreatedShoutsInput>;
  void?: Maybe<VoidUpdateOneRequiredWithoutShoutsInput>;
}

export interface ShoutUpsertWithoutEchosInput {
  update: ShoutUpdateWithoutEchosDataInput;
  create: ShoutCreateWithoutEchosInput;
}

export interface UserUpdateOneRequiredWithoutEchoedShoutsInput {
  create?: Maybe<UserCreateWithoutEchoedShoutsInput>;
  update?: Maybe<UserUpdateWithoutEchoedShoutsDataInput>;
  upsert?: Maybe<UserUpsertWithoutEchoedShoutsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutEchoedShoutsDataInput {
  createdShouts?: Maybe<ShoutUpdateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutUpdateManyInput>;
  echoes?: Maybe<EchoUpdateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<VoidUpdateManyInput>;
  localVoidGeohash?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface EchoUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    EchoCreateWithoutCreatedByInput[] | EchoCreateWithoutCreatedByInput
  >;
  delete?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  set?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  disconnect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  update?: Maybe<
    | EchoUpdateWithWhereUniqueWithoutCreatedByInput[]
    | EchoUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | EchoUpsertWithWhereUniqueWithoutCreatedByInput[]
    | EchoUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface EchoUpdateWithWhereUniqueWithoutCreatedByInput {
  where: EchoWhereUniqueInput;
  data: EchoUpdateWithoutCreatedByDataInput;
}

export interface EchoUpdateWithoutCreatedByDataInput {
  void?: Maybe<VoidUpdateOneRequiredWithoutEchosInput>;
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutEchosInput>;
  echoedBy?: Maybe<UserUpdateOneRequiredWithoutEchoedShoutsInput>;
}

export interface EchoUpsertWithWhereUniqueWithoutCreatedByInput {
  where: EchoWhereUniqueInput;
  update: EchoUpdateWithoutCreatedByDataInput;
  create: EchoCreateWithoutCreatedByInput;
}

export interface EchoScalarWhereInput {
  echoId?: Maybe<ID_Input>;
  echoId_not?: Maybe<ID_Input>;
  echoId_in?: Maybe<ID_Input[] | ID_Input>;
  echoId_not_in?: Maybe<ID_Input[] | ID_Input>;
  echoId_lt?: Maybe<ID_Input>;
  echoId_lte?: Maybe<ID_Input>;
  echoId_gt?: Maybe<ID_Input>;
  echoId_gte?: Maybe<ID_Input>;
  echoId_contains?: Maybe<ID_Input>;
  echoId_not_contains?: Maybe<ID_Input>;
  echoId_starts_with?: Maybe<ID_Input>;
  echoId_not_starts_with?: Maybe<ID_Input>;
  echoId_ends_with?: Maybe<ID_Input>;
  echoId_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
  OR?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
  NOT?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface VoidUpdateManyInput {
  create?: Maybe<VoidCreateInput[] | VoidCreateInput>;
  update?: Maybe<
    | VoidUpdateWithWhereUniqueNestedInput[]
    | VoidUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | VoidUpsertWithWhereUniqueNestedInput[]
    | VoidUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<VoidWhereUniqueInput[] | VoidWhereUniqueInput>;
  connect?: Maybe<VoidWhereUniqueInput[] | VoidWhereUniqueInput>;
  set?: Maybe<VoidWhereUniqueInput[] | VoidWhereUniqueInput>;
  disconnect?: Maybe<VoidWhereUniqueInput[] | VoidWhereUniqueInput>;
  deleteMany?: Maybe<VoidScalarWhereInput[] | VoidScalarWhereInput>;
  updateMany?: Maybe<
    VoidUpdateManyWithWhereNestedInput[] | VoidUpdateManyWithWhereNestedInput
  >;
}

export interface VoidUpdateWithWhereUniqueNestedInput {
  where: VoidWhereUniqueInput;
  data: VoidUpdateDataInput;
}

export interface VoidUpdateDataInput {
  geohash?: Maybe<String>;
  shouts?: Maybe<ShoutUpdateManyWithoutVoidInput>;
  echos?: Maybe<EchoUpdateManyWithoutVoidInput>;
}

export interface VoidUpsertWithWhereUniqueNestedInput {
  where: VoidWhereUniqueInput;
  update: VoidUpdateDataInput;
  create: VoidCreateInput;
}

export interface VoidScalarWhereInput {
  voidId?: Maybe<ID_Input>;
  voidId_not?: Maybe<ID_Input>;
  voidId_in?: Maybe<ID_Input[] | ID_Input>;
  voidId_not_in?: Maybe<ID_Input[] | ID_Input>;
  voidId_lt?: Maybe<ID_Input>;
  voidId_lte?: Maybe<ID_Input>;
  voidId_gt?: Maybe<ID_Input>;
  voidId_gte?: Maybe<ID_Input>;
  voidId_contains?: Maybe<ID_Input>;
  voidId_not_contains?: Maybe<ID_Input>;
  voidId_starts_with?: Maybe<ID_Input>;
  voidId_not_starts_with?: Maybe<ID_Input>;
  voidId_ends_with?: Maybe<ID_Input>;
  voidId_not_ends_with?: Maybe<ID_Input>;
  geohash?: Maybe<String>;
  geohash_not?: Maybe<String>;
  geohash_in?: Maybe<String[] | String>;
  geohash_not_in?: Maybe<String[] | String>;
  geohash_lt?: Maybe<String>;
  geohash_lte?: Maybe<String>;
  geohash_gt?: Maybe<String>;
  geohash_gte?: Maybe<String>;
  geohash_contains?: Maybe<String>;
  geohash_not_contains?: Maybe<String>;
  geohash_starts_with?: Maybe<String>;
  geohash_not_starts_with?: Maybe<String>;
  geohash_ends_with?: Maybe<String>;
  geohash_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<VoidScalarWhereInput[] | VoidScalarWhereInput>;
  OR?: Maybe<VoidScalarWhereInput[] | VoidScalarWhereInput>;
  NOT?: Maybe<VoidScalarWhereInput[] | VoidScalarWhereInput>;
}

export interface VoidUpdateManyWithWhereNestedInput {
  where: VoidScalarWhereInput;
  data: VoidUpdateManyDataInput;
}

export interface VoidUpdateManyDataInput {
  geohash?: Maybe<String>;
}

export interface UserUpsertWithoutEchoedShoutsInput {
  update: UserUpdateWithoutEchoedShoutsDataInput;
  create: UserCreateWithoutEchoedShoutsInput;
}

export interface EchoUpsertWithWhereUniqueWithoutVoidInput {
  where: EchoWhereUniqueInput;
  update: EchoUpdateWithoutVoidDataInput;
  create: EchoCreateWithoutVoidInput;
}

export interface VoidUpsertWithoutShoutsInput {
  update: VoidUpdateWithoutShoutsDataInput;
  create: VoidCreateWithoutShoutsInput;
}

export interface ShoutUpsertWithWhereUniqueWithoutPostedByInput {
  where: ShoutWhereUniqueInput;
  update: ShoutUpdateWithoutPostedByDataInput;
  create: ShoutCreateWithoutPostedByInput;
}

export interface ShoutScalarWhereInput {
  voteCount?: Maybe<Int>;
  voteCount_not?: Maybe<Int>;
  voteCount_in?: Maybe<Int[] | Int>;
  voteCount_not_in?: Maybe<Int[] | Int>;
  voteCount_lt?: Maybe<Int>;
  voteCount_lte?: Maybe<Int>;
  voteCount_gt?: Maybe<Int>;
  voteCount_gte?: Maybe<Int>;
  shoutId?: Maybe<ID_Input>;
  shoutId_not?: Maybe<ID_Input>;
  shoutId_in?: Maybe<ID_Input[] | ID_Input>;
  shoutId_not_in?: Maybe<ID_Input[] | ID_Input>;
  shoutId_lt?: Maybe<ID_Input>;
  shoutId_lte?: Maybe<ID_Input>;
  shoutId_gt?: Maybe<ID_Input>;
  shoutId_gte?: Maybe<ID_Input>;
  shoutId_contains?: Maybe<ID_Input>;
  shoutId_not_contains?: Maybe<ID_Input>;
  shoutId_starts_with?: Maybe<ID_Input>;
  shoutId_not_starts_with?: Maybe<ID_Input>;
  shoutId_ends_with?: Maybe<ID_Input>;
  shoutId_not_ends_with?: Maybe<ID_Input>;
  geohash?: Maybe<String>;
  geohash_not?: Maybe<String>;
  geohash_in?: Maybe<String[] | String>;
  geohash_not_in?: Maybe<String[] | String>;
  geohash_lt?: Maybe<String>;
  geohash_lte?: Maybe<String>;
  geohash_gt?: Maybe<String>;
  geohash_gte?: Maybe<String>;
  geohash_contains?: Maybe<String>;
  geohash_not_contains?: Maybe<String>;
  geohash_starts_with?: Maybe<String>;
  geohash_not_starts_with?: Maybe<String>;
  geohash_ends_with?: Maybe<String>;
  geohash_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  OR?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
  NOT?: Maybe<ShoutScalarWhereInput[] | ShoutScalarWhereInput>;
}

export interface ShoutUpdateManyWithWhereNestedInput {
  where: ShoutScalarWhereInput;
  data: ShoutUpdateManyDataInput;
}

export interface ShoutUpdateManyDataInput {
  voteCount?: Maybe<Int>;
  geohash?: Maybe<String>;
  content?: Maybe<String>;
}

export interface EchoUpdateManyWithoutEchoedByInput {
  create?: Maybe<
    EchoCreateWithoutEchoedByInput[] | EchoCreateWithoutEchoedByInput
  >;
  delete?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  connect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  set?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  disconnect?: Maybe<EchoWhereUniqueInput[] | EchoWhereUniqueInput>;
  update?: Maybe<
    | EchoUpdateWithWhereUniqueWithoutEchoedByInput[]
    | EchoUpdateWithWhereUniqueWithoutEchoedByInput
  >;
  upsert?: Maybe<
    | EchoUpsertWithWhereUniqueWithoutEchoedByInput[]
    | EchoUpsertWithWhereUniqueWithoutEchoedByInput
  >;
  deleteMany?: Maybe<EchoScalarWhereInput[] | EchoScalarWhereInput>;
}

export interface EchoUpdateWithWhereUniqueWithoutEchoedByInput {
  where: EchoWhereUniqueInput;
  data: EchoUpdateWithoutEchoedByDataInput;
}

export interface EchoUpdateWithoutEchoedByDataInput {
  void?: Maybe<VoidUpdateOneRequiredWithoutEchosInput>;
  originalShout?: Maybe<ShoutUpdateOneRequiredWithoutEchosInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutEchoesInput>;
}

export interface EchoUpsertWithWhereUniqueWithoutEchoedByInput {
  where: EchoWhereUniqueInput;
  update: EchoUpdateWithoutEchoedByDataInput;
  create: EchoCreateWithoutEchoedByInput;
}

export interface UserUpsertWithoutEchoesInput {
  update: UserUpdateWithoutEchoesDataInput;
  create: UserCreateWithoutEchoesInput;
}

export interface EchoUpsertWithWhereUniqueWithoutOriginalShoutInput {
  where: EchoWhereUniqueInput;
  update: EchoUpdateWithoutOriginalShoutDataInput;
  create: EchoCreateWithoutOriginalShoutInput;
}

export interface ShoutUpsertWithWhereUniqueNestedInput {
  where: ShoutWhereUniqueInput;
  update: ShoutUpdateDataInput;
  create: ShoutCreateInput;
}

export interface UserUpsertWithoutCreatedShoutsInput {
  update: UserUpdateWithoutCreatedShoutsDataInput;
  create: UserCreateWithoutCreatedShoutsInput;
}

export interface ShoutUpsertWithWhereUniqueWithoutVoidInput {
  where: ShoutWhereUniqueInput;
  update: ShoutUpdateWithoutVoidDataInput;
  create: ShoutCreateWithoutVoidInput;
}

export interface VoidUpsertWithoutEchosInput {
  update: VoidUpdateWithoutEchosDataInput;
  create: VoidCreateWithoutEchosInput;
}

export interface ShoutUpdateInput {
  voteCount?: Maybe<Int>;
  geohash?: Maybe<String>;
  content?: Maybe<String>;
  postedBy?: Maybe<UserUpdateOneRequiredWithoutCreatedShoutsInput>;
  echos?: Maybe<EchoUpdateManyWithoutOriginalShoutInput>;
  void?: Maybe<VoidUpdateOneRequiredWithoutShoutsInput>;
}

export interface ShoutUpdateManyMutationInput {
  voteCount?: Maybe<Int>;
  geohash?: Maybe<String>;
  content?: Maybe<String>;
}

export interface UserCreateInput {
  userId?: Maybe<ID_Input>;
  createdShouts?: Maybe<ShoutCreateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutCreateManyInput>;
  echoedShouts?: Maybe<EchoCreateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoCreateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<VoidCreateManyInput>;
  localVoidGeohash: String;
  email: String;
  password: String;
}

export interface UserUpdateInput {
  createdShouts?: Maybe<ShoutUpdateManyWithoutPostedByInput>;
  savedShouts?: Maybe<ShoutUpdateManyInput>;
  echoedShouts?: Maybe<EchoUpdateManyWithoutEchoedByInput>;
  echoes?: Maybe<EchoUpdateManyWithoutCreatedByInput>;
  savedVoids?: Maybe<VoidUpdateManyInput>;
  localVoidGeohash?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  localVoidGeohash?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface VoidUpdateInput {
  geohash?: Maybe<String>;
  shouts?: Maybe<ShoutUpdateManyWithoutVoidInput>;
  echos?: Maybe<EchoUpdateManyWithoutVoidInput>;
}

export interface VoidUpdateManyMutationInput {
  geohash?: Maybe<String>;
}

export interface EchoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EchoWhereInput>;
  AND?: Maybe<EchoSubscriptionWhereInput[] | EchoSubscriptionWhereInput>;
  OR?: Maybe<EchoSubscriptionWhereInput[] | EchoSubscriptionWhereInput>;
  NOT?: Maybe<EchoSubscriptionWhereInput[] | EchoSubscriptionWhereInput>;
}

export interface ShoutSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShoutWhereInput>;
  AND?: Maybe<ShoutSubscriptionWhereInput[] | ShoutSubscriptionWhereInput>;
  OR?: Maybe<ShoutSubscriptionWhereInput[] | ShoutSubscriptionWhereInput>;
  NOT?: Maybe<ShoutSubscriptionWhereInput[] | ShoutSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface VoidSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VoidWhereInput>;
  AND?: Maybe<VoidSubscriptionWhereInput[] | VoidSubscriptionWhereInput>;
  OR?: Maybe<VoidSubscriptionWhereInput[] | VoidSubscriptionWhereInput>;
  NOT?: Maybe<VoidSubscriptionWhereInput[] | VoidSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Echo {
  echoId: ID_Output;
  createdAt: DateTimeOutput;
}

export interface EchoPromise extends Promise<Echo>, Fragmentable {
  echoId: () => Promise<ID_Output>;
  void: <T = VoidPromise>() => T;
  originalShout: <T = ShoutPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  echoedBy: <T = UserPromise>() => T;
}

export interface EchoSubscription
  extends Promise<AsyncIterator<Echo>>,
    Fragmentable {
  echoId: () => Promise<AsyncIterator<ID_Output>>;
  void: <T = VoidSubscription>() => T;
  originalShout: <T = ShoutSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
  echoedBy: <T = UserSubscription>() => T;
}

export interface EchoNullablePromise
  extends Promise<Echo | null>,
    Fragmentable {
  echoId: () => Promise<ID_Output>;
  void: <T = VoidPromise>() => T;
  originalShout: <T = ShoutPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  echoedBy: <T = UserPromise>() => T;
}

export interface Void {
  voidId: ID_Output;
  geohash: String;
  createdAt: DateTimeOutput;
}

export interface VoidPromise extends Promise<Void>, Fragmentable {
  voidId: () => Promise<ID_Output>;
  geohash: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  shouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echos: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VoidSubscription
  extends Promise<AsyncIterator<Void>>,
    Fragmentable {
  voidId: () => Promise<AsyncIterator<ID_Output>>;
  geohash: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  shouts: <T = Promise<AsyncIterator<ShoutSubscription>>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echos: <T = Promise<AsyncIterator<EchoSubscription>>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VoidNullablePromise
  extends Promise<Void | null>,
    Fragmentable {
  voidId: () => Promise<ID_Output>;
  geohash: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  shouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echos: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Shout {
  voteCount: Int;
  shoutId: ID_Output;
  geohash: String;
  createdAt: DateTimeOutput;
  content: String;
}

export interface ShoutPromise extends Promise<Shout>, Fragmentable {
  voteCount: () => Promise<Int>;
  shoutId: () => Promise<ID_Output>;
  geohash: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  postedBy: <T = UserPromise>() => T;
  echos: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  void: <T = VoidPromise>() => T;
}

export interface ShoutSubscription
  extends Promise<AsyncIterator<Shout>>,
    Fragmentable {
  voteCount: () => Promise<AsyncIterator<Int>>;
  shoutId: () => Promise<AsyncIterator<ID_Output>>;
  geohash: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  postedBy: <T = UserSubscription>() => T;
  echos: <T = Promise<AsyncIterator<EchoSubscription>>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  void: <T = VoidSubscription>() => T;
}

export interface ShoutNullablePromise
  extends Promise<Shout | null>,
    Fragmentable {
  voteCount: () => Promise<Int>;
  shoutId: () => Promise<ID_Output>;
  geohash: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  postedBy: <T = UserPromise>() => T;
  echos: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  void: <T = VoidPromise>() => T;
}

export interface User {
  createdAt: DateTimeOutput;
  userId: ID_Output;
  localVoidGeohash: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
  createdShouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedShouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoedShouts: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoes: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedVoids: <T = FragmentableArray<Void>>(args?: {
    where?: VoidWhereInput;
    orderBy?: VoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  localVoidGeohash: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  createdShouts: <T = Promise<AsyncIterator<ShoutSubscription>>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedShouts: <T = Promise<AsyncIterator<ShoutSubscription>>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoedShouts: <T = Promise<AsyncIterator<EchoSubscription>>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoes: <T = Promise<AsyncIterator<EchoSubscription>>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedVoids: <T = Promise<AsyncIterator<VoidSubscription>>>(args?: {
    where?: VoidWhereInput;
    orderBy?: VoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  localVoidGeohash: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
  createdShouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedShouts: <T = FragmentableArray<Shout>>(args?: {
    where?: ShoutWhereInput;
    orderBy?: ShoutOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoedShouts: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  echoes: <T = FragmentableArray<Echo>>(args?: {
    where?: EchoWhereInput;
    orderBy?: EchoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedVoids: <T = FragmentableArray<Void>>(args?: {
    where?: VoidWhereInput;
    orderBy?: VoidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  localVoidGeohash: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface EchoConnection {
  pageInfo: PageInfo;
  edges: EchoEdge[];
}

export interface EchoConnectionPromise
  extends Promise<EchoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EchoEdge>>() => T;
  aggregate: <T = AggregateEchoPromise>() => T;
}

export interface EchoConnectionSubscription
  extends Promise<AsyncIterator<EchoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EchoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEchoSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface EchoEdge {
  node: Echo;
  cursor: String;
}

export interface EchoEdgePromise extends Promise<EchoEdge>, Fragmentable {
  node: <T = EchoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EchoEdgeSubscription
  extends Promise<AsyncIterator<EchoEdge>>,
    Fragmentable {
  node: <T = EchoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEcho {
  count: Int;
}

export interface AggregateEchoPromise
  extends Promise<AggregateEcho>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEchoSubscription
  extends Promise<AsyncIterator<AggregateEcho>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShoutConnection {
  pageInfo: PageInfo;
  edges: ShoutEdge[];
}

export interface ShoutConnectionPromise
  extends Promise<ShoutConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShoutEdge>>() => T;
  aggregate: <T = AggregateShoutPromise>() => T;
}

export interface ShoutConnectionSubscription
  extends Promise<AsyncIterator<ShoutConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShoutEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShoutSubscription>() => T;
}

export interface ShoutEdge {
  node: Shout;
  cursor: String;
}

export interface ShoutEdgePromise extends Promise<ShoutEdge>, Fragmentable {
  node: <T = ShoutPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShoutEdgeSubscription
  extends Promise<AsyncIterator<ShoutEdge>>,
    Fragmentable {
  node: <T = ShoutSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShout {
  count: Int;
}

export interface AggregateShoutPromise
  extends Promise<AggregateShout>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShoutSubscription
  extends Promise<AsyncIterator<AggregateShout>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VoidConnection {
  pageInfo: PageInfo;
  edges: VoidEdge[];
}

export interface VoidConnectionPromise
  extends Promise<VoidConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VoidEdge>>() => T;
  aggregate: <T = AggregateVoidPromise>() => T;
}

export interface VoidConnectionSubscription
  extends Promise<AsyncIterator<VoidConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VoidEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVoidSubscription>() => T;
}

export interface VoidEdge {
  node: Void;
  cursor: String;
}

export interface VoidEdgePromise extends Promise<VoidEdge>, Fragmentable {
  node: <T = VoidPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VoidEdgeSubscription
  extends Promise<AsyncIterator<VoidEdge>>,
    Fragmentable {
  node: <T = VoidSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVoid {
  count: Int;
}

export interface AggregateVoidPromise
  extends Promise<AggregateVoid>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVoidSubscription
  extends Promise<AsyncIterator<AggregateVoid>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface EchoSubscriptionPayload {
  mutation: MutationType;
  node: Echo;
  updatedFields: String[];
  previousValues: EchoPreviousValues;
}

export interface EchoSubscriptionPayloadPromise
  extends Promise<EchoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EchoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EchoPreviousValuesPromise>() => T;
}

export interface EchoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EchoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EchoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EchoPreviousValuesSubscription>() => T;
}

export interface EchoPreviousValues {
  echoId: ID_Output;
  createdAt: DateTimeOutput;
}

export interface EchoPreviousValuesPromise
  extends Promise<EchoPreviousValues>,
    Fragmentable {
  echoId: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface EchoPreviousValuesSubscription
  extends Promise<AsyncIterator<EchoPreviousValues>>,
    Fragmentable {
  echoId: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShoutSubscriptionPayload {
  mutation: MutationType;
  node: Shout;
  updatedFields: String[];
  previousValues: ShoutPreviousValues;
}

export interface ShoutSubscriptionPayloadPromise
  extends Promise<ShoutSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShoutPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShoutPreviousValuesPromise>() => T;
}

export interface ShoutSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShoutSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShoutSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShoutPreviousValuesSubscription>() => T;
}

export interface ShoutPreviousValues {
  voteCount: Int;
  shoutId: ID_Output;
  geohash: String;
  createdAt: DateTimeOutput;
  content: String;
}

export interface ShoutPreviousValuesPromise
  extends Promise<ShoutPreviousValues>,
    Fragmentable {
  voteCount: () => Promise<Int>;
  shoutId: () => Promise<ID_Output>;
  geohash: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface ShoutPreviousValuesSubscription
  extends Promise<AsyncIterator<ShoutPreviousValues>>,
    Fragmentable {
  voteCount: () => Promise<AsyncIterator<Int>>;
  shoutId: () => Promise<AsyncIterator<ID_Output>>;
  geohash: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  createdAt: DateTimeOutput;
  userId: ID_Output;
  localVoidGeohash: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
  localVoidGeohash: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
  localVoidGeohash: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface VoidSubscriptionPayload {
  mutation: MutationType;
  node: Void;
  updatedFields: String[];
  previousValues: VoidPreviousValues;
}

export interface VoidSubscriptionPayloadPromise
  extends Promise<VoidSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VoidPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VoidPreviousValuesPromise>() => T;
}

export interface VoidSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VoidSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VoidSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VoidPreviousValuesSubscription>() => T;
}

export interface VoidPreviousValues {
  voidId: ID_Output;
  geohash: String;
  createdAt: DateTimeOutput;
}

export interface VoidPreviousValuesPromise
  extends Promise<VoidPreviousValues>,
    Fragmentable {
  voidId: () => Promise<ID_Output>;
  geohash: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface VoidPreviousValuesSubscription
  extends Promise<AsyncIterator<VoidPreviousValues>>,
    Fragmentable {
  voidId: () => Promise<AsyncIterator<ID_Output>>;
  geohash: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Shout",
    embedded: false
  },
  {
    name: "Echo",
    embedded: false
  },
  {
    name: "Void",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
