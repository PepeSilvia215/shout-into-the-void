module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateContent {
  count: Int!
}

type AggregateShoutInVoid {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Content {
  contentId: ID!
  createdAt: DateTime!
  createdBy: User!
  message: String!
  includeUsername: Boolean!
}

type ContentConnection {
  pageInfo: PageInfo!
  edges: [ContentEdge]!
  aggregate: AggregateContent!
}

input ContentCreateInput {
  contentId: ID
  createdBy: UserCreateOneInput!
  message: String!
  includeUsername: Boolean!
}

input ContentCreateOneInput {
  create: ContentCreateInput
  connect: ContentWhereUniqueInput
}

type ContentEdge {
  node: Content!
  cursor: String!
}

enum ContentOrderByInput {
  contentId_ASC
  contentId_DESC
  createdAt_ASC
  createdAt_DESC
  message_ASC
  message_DESC
  includeUsername_ASC
  includeUsername_DESC
}

type ContentPreviousValues {
  contentId: ID!
  createdAt: DateTime!
  message: String!
  includeUsername: Boolean!
}

type ContentSubscriptionPayload {
  mutation: MutationType!
  node: Content
  updatedFields: [String!]
  previousValues: ContentPreviousValues
}

input ContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContentWhereInput
  AND: [ContentSubscriptionWhereInput!]
  OR: [ContentSubscriptionWhereInput!]
  NOT: [ContentSubscriptionWhereInput!]
}

input ContentUpdateDataInput {
  createdBy: UserUpdateOneRequiredInput
  message: String
  includeUsername: Boolean
}

input ContentUpdateInput {
  createdBy: UserUpdateOneRequiredInput
  message: String
  includeUsername: Boolean
}

input ContentUpdateManyMutationInput {
  message: String
  includeUsername: Boolean
}

input ContentUpdateOneRequiredInput {
  create: ContentCreateInput
  update: ContentUpdateDataInput
  upsert: ContentUpsertNestedInput
  connect: ContentWhereUniqueInput
}

input ContentUpsertNestedInput {
  update: ContentUpdateDataInput!
  create: ContentCreateInput!
}

input ContentWhereInput {
  contentId: ID
  contentId_not: ID
  contentId_in: [ID!]
  contentId_not_in: [ID!]
  contentId_lt: ID
  contentId_lte: ID
  contentId_gt: ID
  contentId_gte: ID
  contentId_contains: ID
  contentId_not_contains: ID
  contentId_starts_with: ID
  contentId_not_starts_with: ID
  contentId_ends_with: ID
  contentId_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdBy: UserWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  includeUsername: Boolean
  includeUsername_not: Boolean
  AND: [ContentWhereInput!]
  OR: [ContentWhereInput!]
  NOT: [ContentWhereInput!]
}

input ContentWhereUniqueInput {
  contentId: ID
}

scalar DateTime

scalar Long

type Mutation {
  createContent(data: ContentCreateInput!): Content!
  updateContent(data: ContentUpdateInput!, where: ContentWhereUniqueInput!): Content
  updateManyContents(data: ContentUpdateManyMutationInput!, where: ContentWhereInput): BatchPayload!
  upsertContent(where: ContentWhereUniqueInput!, create: ContentCreateInput!, update: ContentUpdateInput!): Content!
  deleteContent(where: ContentWhereUniqueInput!): Content
  deleteManyContents(where: ContentWhereInput): BatchPayload!
  createShoutInVoid(data: ShoutInVoidCreateInput!): ShoutInVoid!
  updateShoutInVoid(data: ShoutInVoidUpdateInput!, where: ShoutInVoidWhereUniqueInput!): ShoutInVoid
  updateManyShoutInVoids(data: ShoutInVoidUpdateManyMutationInput!, where: ShoutInVoidWhereInput): BatchPayload!
  upsertShoutInVoid(where: ShoutInVoidWhereUniqueInput!, create: ShoutInVoidCreateInput!, update: ShoutInVoidUpdateInput!): ShoutInVoid!
  deleteShoutInVoid(where: ShoutInVoidWhereUniqueInput!): ShoutInVoid
  deleteManyShoutInVoids(where: ShoutInVoidWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  content(where: ContentWhereUniqueInput!): Content
  contents(where: ContentWhereInput, orderBy: ContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Content]!
  contentsConnection(where: ContentWhereInput, orderBy: ContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContentConnection!
  shoutInVoid(where: ShoutInVoidWhereUniqueInput!): ShoutInVoid
  shoutInVoids(where: ShoutInVoidWhereInput, orderBy: ShoutInVoidOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ShoutInVoid]!
  shoutInVoidsConnection(where: ShoutInVoidWhereInput, orderBy: ShoutInVoidOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShoutInVoidConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type ShoutInVoid {
  shoutInVoidId: ID!
  createdAt: DateTime!
  shoutedBy: User!
  content: Content!
  voteCount: Int!
}

type ShoutInVoidConnection {
  pageInfo: PageInfo!
  edges: [ShoutInVoidEdge]!
  aggregate: AggregateShoutInVoid!
}

input ShoutInVoidCreateInput {
  shoutInVoidId: ID
  shoutedBy: UserCreateOneWithoutShoutsInVoidsInput!
  content: ContentCreateOneInput!
  voteCount: Int!
}

input ShoutInVoidCreateManyWithoutShoutedByInput {
  create: [ShoutInVoidCreateWithoutShoutedByInput!]
  connect: [ShoutInVoidWhereUniqueInput!]
}

input ShoutInVoidCreateWithoutShoutedByInput {
  shoutInVoidId: ID
  content: ContentCreateOneInput!
  voteCount: Int!
}

type ShoutInVoidEdge {
  node: ShoutInVoid!
  cursor: String!
}

enum ShoutInVoidOrderByInput {
  shoutInVoidId_ASC
  shoutInVoidId_DESC
  createdAt_ASC
  createdAt_DESC
  voteCount_ASC
  voteCount_DESC
}

type ShoutInVoidPreviousValues {
  shoutInVoidId: ID!
  createdAt: DateTime!
  voteCount: Int!
}

input ShoutInVoidScalarWhereInput {
  shoutInVoidId: ID
  shoutInVoidId_not: ID
  shoutInVoidId_in: [ID!]
  shoutInVoidId_not_in: [ID!]
  shoutInVoidId_lt: ID
  shoutInVoidId_lte: ID
  shoutInVoidId_gt: ID
  shoutInVoidId_gte: ID
  shoutInVoidId_contains: ID
  shoutInVoidId_not_contains: ID
  shoutInVoidId_starts_with: ID
  shoutInVoidId_not_starts_with: ID
  shoutInVoidId_ends_with: ID
  shoutInVoidId_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  voteCount: Int
  voteCount_not: Int
  voteCount_in: [Int!]
  voteCount_not_in: [Int!]
  voteCount_lt: Int
  voteCount_lte: Int
  voteCount_gt: Int
  voteCount_gte: Int
  AND: [ShoutInVoidScalarWhereInput!]
  OR: [ShoutInVoidScalarWhereInput!]
  NOT: [ShoutInVoidScalarWhereInput!]
}

type ShoutInVoidSubscriptionPayload {
  mutation: MutationType!
  node: ShoutInVoid
  updatedFields: [String!]
  previousValues: ShoutInVoidPreviousValues
}

input ShoutInVoidSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ShoutInVoidWhereInput
  AND: [ShoutInVoidSubscriptionWhereInput!]
  OR: [ShoutInVoidSubscriptionWhereInput!]
  NOT: [ShoutInVoidSubscriptionWhereInput!]
}

input ShoutInVoidUpdateInput {
  shoutedBy: UserUpdateOneRequiredWithoutShoutsInVoidsInput
  content: ContentUpdateOneRequiredInput
  voteCount: Int
}

input ShoutInVoidUpdateManyDataInput {
  voteCount: Int
}

input ShoutInVoidUpdateManyMutationInput {
  voteCount: Int
}

input ShoutInVoidUpdateManyWithoutShoutedByInput {
  create: [ShoutInVoidCreateWithoutShoutedByInput!]
  delete: [ShoutInVoidWhereUniqueInput!]
  connect: [ShoutInVoidWhereUniqueInput!]
  set: [ShoutInVoidWhereUniqueInput!]
  disconnect: [ShoutInVoidWhereUniqueInput!]
  update: [ShoutInVoidUpdateWithWhereUniqueWithoutShoutedByInput!]
  upsert: [ShoutInVoidUpsertWithWhereUniqueWithoutShoutedByInput!]
  deleteMany: [ShoutInVoidScalarWhereInput!]
  updateMany: [ShoutInVoidUpdateManyWithWhereNestedInput!]
}

input ShoutInVoidUpdateManyWithWhereNestedInput {
  where: ShoutInVoidScalarWhereInput!
  data: ShoutInVoidUpdateManyDataInput!
}

input ShoutInVoidUpdateWithoutShoutedByDataInput {
  content: ContentUpdateOneRequiredInput
  voteCount: Int
}

input ShoutInVoidUpdateWithWhereUniqueWithoutShoutedByInput {
  where: ShoutInVoidWhereUniqueInput!
  data: ShoutInVoidUpdateWithoutShoutedByDataInput!
}

input ShoutInVoidUpsertWithWhereUniqueWithoutShoutedByInput {
  where: ShoutInVoidWhereUniqueInput!
  update: ShoutInVoidUpdateWithoutShoutedByDataInput!
  create: ShoutInVoidCreateWithoutShoutedByInput!
}

input ShoutInVoidWhereInput {
  shoutInVoidId: ID
  shoutInVoidId_not: ID
  shoutInVoidId_in: [ID!]
  shoutInVoidId_not_in: [ID!]
  shoutInVoidId_lt: ID
  shoutInVoidId_lte: ID
  shoutInVoidId_gt: ID
  shoutInVoidId_gte: ID
  shoutInVoidId_contains: ID
  shoutInVoidId_not_contains: ID
  shoutInVoidId_starts_with: ID
  shoutInVoidId_not_starts_with: ID
  shoutInVoidId_ends_with: ID
  shoutInVoidId_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  shoutedBy: UserWhereInput
  content: ContentWhereInput
  voteCount: Int
  voteCount_not: Int
  voteCount_in: [Int!]
  voteCount_not_in: [Int!]
  voteCount_lt: Int
  voteCount_lte: Int
  voteCount_gt: Int
  voteCount_gte: Int
  AND: [ShoutInVoidWhereInput!]
  OR: [ShoutInVoidWhereInput!]
  NOT: [ShoutInVoidWhereInput!]
}

input ShoutInVoidWhereUniqueInput {
  shoutInVoidId: ID
}

type Subscription {
  content(where: ContentSubscriptionWhereInput): ContentSubscriptionPayload
  shoutInVoid(where: ShoutInVoidSubscriptionWhereInput): ShoutInVoidSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  userId: ID!
  createdAt: DateTime!
  username: String!
  password: String!
  currentLocationGeohash: String!
  shoutsInVoids(where: ShoutInVoidWhereInput, orderBy: ShoutInVoidOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ShoutInVoid!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  userId: ID
  username: String!
  password: String!
  currentLocationGeohash: String!
  shoutsInVoids: ShoutInVoidCreateManyWithoutShoutedByInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutShoutsInVoidsInput {
  create: UserCreateWithoutShoutsInVoidsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutShoutsInVoidsInput {
  userId: ID
  username: String!
  password: String!
  currentLocationGeohash: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  userId_ASC
  userId_DESC
  createdAt_ASC
  createdAt_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  currentLocationGeohash_ASC
  currentLocationGeohash_DESC
}

type UserPreviousValues {
  userId: ID!
  createdAt: DateTime!
  username: String!
  password: String!
  currentLocationGeohash: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  username: String
  password: String
  currentLocationGeohash: String
  shoutsInVoids: ShoutInVoidUpdateManyWithoutShoutedByInput
}

input UserUpdateInput {
  username: String
  password: String
  currentLocationGeohash: String
  shoutsInVoids: ShoutInVoidUpdateManyWithoutShoutedByInput
}

input UserUpdateManyMutationInput {
  username: String
  password: String
  currentLocationGeohash: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutShoutsInVoidsInput {
  create: UserCreateWithoutShoutsInVoidsInput
  update: UserUpdateWithoutShoutsInVoidsDataInput
  upsert: UserUpsertWithoutShoutsInVoidsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutShoutsInVoidsDataInput {
  username: String
  password: String
  currentLocationGeohash: String
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutShoutsInVoidsInput {
  update: UserUpdateWithoutShoutsInVoidsDataInput!
  create: UserCreateWithoutShoutsInVoidsInput!
}

input UserWhereInput {
  userId: ID
  userId_not: ID
  userId_in: [ID!]
  userId_not_in: [ID!]
  userId_lt: ID
  userId_lte: ID
  userId_gt: ID
  userId_gte: ID
  userId_contains: ID
  userId_not_contains: ID
  userId_starts_with: ID
  userId_not_starts_with: ID
  userId_ends_with: ID
  userId_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  currentLocationGeohash: String
  currentLocationGeohash_not: String
  currentLocationGeohash_in: [String!]
  currentLocationGeohash_not_in: [String!]
  currentLocationGeohash_lt: String
  currentLocationGeohash_lte: String
  currentLocationGeohash_gt: String
  currentLocationGeohash_gte: String
  currentLocationGeohash_contains: String
  currentLocationGeohash_not_contains: String
  currentLocationGeohash_starts_with: String
  currentLocationGeohash_not_starts_with: String
  currentLocationGeohash_ends_with: String
  currentLocationGeohash_not_ends_with: String
  shoutsInVoids_every: ShoutInVoidWhereInput
  shoutsInVoids_some: ShoutInVoidWhereInput
  shoutsInVoids_none: ShoutInVoidWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  userId: ID
}
`
      }
    